# 命令

## 用户/组

$：普通管理员

\#：超级管理员

su 用户名：切换用户

groupadd 组名：创建组

useradd 用户名 -g 组名：创建用户同时加入组

usermod -g 组名 用户名：修改用户所在主组

chmod [u/g/o] [+/-] [r/w/x]：修改文件权限

1. u：文件拥有者
2. g：文件拥有者所在的组
3. o：其他用户
4. +：增加权限
5. -：删除权限
6. r：读权限
7. w：写权限
8. x：执行权限

ssh [-p portId] user@host：以指定用户远程登录到指定主机；若本地用户名与远程用户名一致，登录时可以省略用户名；可以添加-p portId指定登录请求发送到的远程主机端口号，默认为22。

## 编辑

pwd：显示当前目录

tree：树形结构显示目录，需安装tree包

ls：显示文件或目录

1. -l：列出文件详细信息

2. -a：列出当前目录下包含隐藏的所有文件及目录

stat：显示指定文件的超详细信息

cd ~：进入home下当前用户的文件夹

cd：切换到指定文件夹

find：在当前查找某文件

cat：查看文件内容

more、less：分页显示文本文件内容

head、tail：显示文件头、尾内容

grep：在文本文件中查找某个关键词

wc：统计文本中行数、字符、字符数

touch 文件名：创建空文件

echo：创建带有内容的文件

ctrl+insert：复制

cp：复制

shift+insert：粘贴

rm：删除

1. -r：递归删除子目录及文件
2. -f：强制删除

mv：移动

mkdir：创建文件夹

1. -p：若无父目录，则创建

rmdir：删除空文件夹

1. -p：递归删除空的父目录

esc+q：退出当前输入

clear：清屏

## 压缩

tar：压缩

1. 必须选一
    1. -c：创建压缩档案（只打包不压缩）
    2. -x：解压缩 
    3. -t：查看内容
    4. -r：向压缩归档文件末尾追加文件

2. 压缩方式
    1. -z：使用gzip压缩
    2. -j：使用bzip2压缩

3. -v：显示压缩/解压缩过程

4. -f：打包成指定文件名

## 网络

ifconfig：查看网络情况

netstat：显示网络状态信息

ping：测试连通性

## 进程

kill 端口号：杀死进程

1. -9 端口号：彻底杀死进程

ps：ps命令：提供系统过去进程信息的一次性快照

1. ps H -eo user,pid,ppid,tid,time,%cpu,cmd --sort=%cpu 打印用户、进程id、父进程id、线程id、运行时间、CPU使用率、启动命令，并按CPU使用率排序。
2. ps -ef | grep 关键字：查看相关进程

top：反应的是系统进程动态信息，默认10s更新一次。ps和top都是从/proc目录下读取进程的状态信息，内核把当前系统进程的各种有用信息都放在这个伪目录下。

1. VIRT 虚拟内存用量
2. RES 物理内存用量
3. SHR 共享内存用量
4. %MEM 内存用量

jskack：用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。

1. 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息；

2. 如果要排查正在运行的程序：
    1. top查看进程，找出pid 
    2. top -H -p PID查看该进程下的线程，找出tid
    3. 因为pid展示的thread _id是十进制的，在jstack文件里是16进制的，所以通过printf “0x%x” tid将线程id进行16进制转换。
    4. 运行jstack 进程id（十进制）> stack.log，将堆栈内容打印重定向到stack.log中。
    5. 使用vim stack.log进行查看，或者grep 关键词 文件名，搜索nid=线程号（16进制）。

3. 比如可以看到s0、s1、eden、old、metaspace都已经爆了，且FGC次数一直在增加，但是却没有回收到任何空间，导致FGC一直在跑，进入循环，涉及回内存泄漏；

# 定位问题

​		如果是Java应用出现了问题，看日志，看是什么地方抛出了什么异常。

1. 内存溢出：如果服务挂了，使用JDK自带的命令行工具jmap；服务没挂，使用jstack，把JVM的内存结构dump下来，得到一个dump格式的文件。使用JDK自带的visualvm工具打开，看看哪些对象占用内存较高，若同一个类型的对象占用内存较高，可以认为该对象在不断的创建，回去找到相应代码改掉即可。若整个内存分配很正常，则只是单纯的内存不够，此时可以考虑优化JVM的启动参数，如-Xmx。或者发现mirrorGC或majorGC很频繁，此时可以调节JVM young区和old区的比例，或者调整JVM垃圾回收的暂停时间。
2. CPU负载飙高：一般出现了死循环
3. 接口响应慢

# CPU资源不足

1. 优化程序内部的线程使用，确保无冗余的线程配置；
2. 增加虚拟机或容器的CPU配置，提升机器总的计算能力。

# 项目部署

​		打成jar包，将项目target目录下面的项目jar包，拷贝到linux环境的要部署的目录下，将要使用的配置文件同样拷贝在这一目录下（可以指定另一个目录），并修改相应的配置参数的值，执行nohup java -jar 项目.jar application.yml & 命令。

1. &：后台运行 关闭控制台不影响

2. nohup：永久运行 退出shell也不影响

# vim编辑器

esc：切到命令行模式

:：切换到底行模式

a/i/o：在命令行模式下切换到插入模式

:wq：保存文件并退出

:wq 文件名：保存为指定文件并退出

:q!：不保存文件并强制退出

dd：删除

yy：复制

pp：粘贴

u：撤销

\>：重定向

\>>：追加内容重定向

<< xxx：从键盘输入内容到文件，以xxx结束输入

