# Java EE

## Java EE

### 名词解释

**web容器**：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接和容器中的环境变量接接口互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。

**Web container**：实现J2EE体系结构中Web组件协议的容器。这个协议规定了一个Web组件运行时的环境，包括安全，一致性，生命周期管理，事务，配置和其它的服务。一个提供和JSP和J2EE平台APIs界面相同服务的容器。一个Web container 由Web服务器或者J2EE服务器提供。

**EJB容器**：Enterprise java bean 容器。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。一个实现了J2EE体系结构中EJB组件规范的容器。 这个规范指定了一个Enterprise bean的运行时环境，包括安全，一致性，生命周期，事务， 配置，和其他的服务。

**JNDI**：Java Naming & Directory Interface，JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。

**JMS**：Java Message Service，JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。

**JTA**：Java Transaction API，JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。

**JAF**：Java Action FrameWork，JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。

**RMI/IIOP**：Remote Method Invocation /internet对象请求中介协议，主要用于通过远程调用服务。

## 网络通信

​		网络通信三要素：ip+端口+协议

### Socket

​		将网络通信抽象成两个Socket对象之间的通信，数据在两个Socket之间通过IO传输。

​		服务器端：ServerSocket提供TCP连接的实例，ServerSocket serverSocket = new ServerSocket(端口号) ，serverSocket.accept()获取客户端请求Socket对象。

​		客户端：Socket提供的实例，Socket client = new Socket(IP地址，端口号)

### MAC地址

​		网卡的硬件标识

### IP地址

1. 网络中主机的唯一标识，标识主机在网络中的位置。
2. 用点分十进制。IPV4：32位，IPV6：128位
3. IP地址=网络号码+主机地址
4. A类IP地址：第一段号码为网络号码，剩下三段为本地计算机的号码。以0开头，网络号码占7位，主机号码占24位，表示的IP地址个数再减2，因为全为0或全为1不能表示IP地址。
5. B类IP地址：前两段号码为网络号码，剩下两段为本地计算机的号码。以10开头，网络号码占14位，主机号码占16位，表示的IP地址个数再减2。
6. C类IP地址：前三段号码为网络号码，剩下一段为本地计算机的号码。以110开头，网络号码占21位，主机号码占8位，表示的IP地址个数再减2。
7. 无类别域间路由CIDR：例如192.168.2.100/22，反斜杠后面的22代表该IP地址前22位为网络号码，所以主机能表示的IP地址的个数为2^10-2。
8. 子网掩码：与CIDR同时出现，例如192.168.2.100/22，子网掩码为前22位均为1，后10位均为0。
9. 网络号=IP&子网掩码。例如求192.168.2.100/22的子网掩码和网络号，子网掩码=255.255.252.0 ，即22个1+10个0，每4位用1个十进制表示，网络号=192.168.0.0

### 端口

物理端口：网卡口

逻辑端口：标识进程的逻辑地址

有效端口号：0-65535，0-1023为系统使用或保留端口

常用端口号：

1. 21：FTP文件传输协议
2. 22：SSH
3. 23：Telnet远程登录服务
4. 53：DNS域名服务器
5. 80：HTTP超文本传输协议
6. 443：HTTPS
7. 1080：Sockets
8. 1521：Oracle
9. 3306：MySQL

### 点对点/端对端

**点对点**：点到点通信是针对数据链路层或网络层来说的，因为数据链路层只负责直接相连的两个节点之间的通信，一个节点的数据链路层接受 ip 层数据并封装之后，就把数据帧从链路上发送到与其相邻的下一个节点。 点对点是基于 MAC 地址和或者 IP 地址，是指一个设备发数据给与该这边直接连接的其他设备，这台设备又在合适的时候将数据传递给与它相连的下一个设备，通过一台一台直接相连的设备把数据传递到接收端。
**端到端**：端到端通信是针对传输层来说的，传输层为网络中的主机提供端到端的通信。因为无论 tcp 还是 udp协议，都要负责把上层交付的数据从发送端传输到接收端，不论其中间跨越多少节点。只不过 tcp 比较可靠而 udp 不可靠而已。所以称之为端到端，也就是从发送端到接收端。它是一个网络连接，指的是在数据传输之前，在发送端与接收端之间（忽略中间有多少设备）为数据的传输建立一条链路，链路建立以后，发送端就可以发送数据。

## I/O

### BIO

1. 同步阻塞式IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 
2. 线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成。
3. 在while循环中服务端会调用accept方法等待接收客户端的连接请求，一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成。 
4. 客户端发送请求后，先咨询服务端是否有线程相应，如果没有则会一直等待或者遭到拒绝请求，如果有的话，客户端会线程会等待请求结束后才继续执行。
5. 如果BIO要能够同时处理多个客户端请求，就必须使用多线程，即每次accept阻塞等待来自客户端请求，一旦受到连接请求就建立通信套接字同时开启一个新的线程来处理这个套接字的数据读写请求，然后立刻又继续accept等待其他客户端连接请求，即为每一个客户端连接请求都创建一个线程来单独处理，
6. BIO方式适用于连接数目比较小且固定的场景，这种方式对服务器资源要求比较高，并发局限于应用中。
7. 虽然此时服务器具备了高并发能力，即能够同时处理多个客户端请求了，但是却带来了一个问题，随着开启的线程数目增多，将会消耗过多的内存资源，导致服务器变慢甚至崩溃，NIO可以一定程度解决这个问题。

### NIO

1. 同步非阻塞式IO，服务器实现模式为一个请求一个线程，采用了事件驱动的思想来实现了一个多路转换器。 客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。另外NIO的非阻塞，需要一直轮询，也是一个比较耗资源的。当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题。
2. 线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成
3. NIO适合处理连接数目特别多，但是连接比较短（轻操作）的场景，Jetty，Mina，ZooKeeper等都是基于java nio实现。比如聊天服务器，并发局限于应用中

#### 多路复用

1. NIO与BIO最大的区别就是只需要开启一个线程就可以处理来自多个客户端的IO事件，这是怎么做到的呢？就是多路复用器，可以监听来自多个客户端的IO事件。
    1. 若服务端监听到客户端连接请求，便为其建立通信套接字(java中就是通道)，然后返回继续监听，若同时有多个客户端连接请求到来也可以全部收到，依次为它们都建立通信套接字。 
    2. 若服务端监听到来自已经创建了通信套接字的客户端发送来的数据，就会调用对应接口处理接收到的数据，若同时有多个客户端发来数据也可以依次进行处理。 
    3. 监听多个客户端的连接请求和接收数据请求同时还能监听自己时候有数据要发送。 

2. 总之就是在一个线程中就可以调用多路复用接口（java中是select）阻塞同时监听来自多个客户端的IO请求，一旦有收到IO请求就调用对应函数处理。 
3. Jdk1.5创造了一个假的nio 用一个HanderExecutorPool来限定了线程数量,但只是解决了服务器端不会因为并发太多而死掉,但解决不了并发大而响应越来越慢的。为了解决这个问题，引入3个NIO相关概念：Buffer缓冲区、Channel通道、Selector多路复用选择器。

#### Buffer缓冲区

​		难用的buffer是一个抽象的对象，下面还有ByteBuffer、IntBuffer。LongBuffer等子类，相比老的IO将数据直接读/写到Stream对象，NIO是将所有数据都用到缓冲区处理，它本质上是一个数组，提供了位置、容量、上限等操作方法。

#### Channel 通道

​		如自来水管一样,支持网络数据从Channel中读写，通道写流最大不同是通道是双向的，而流是一个方向上移动(InputStream/OutputStream)，通道可用于读/写或读写同时进行，它还可以和下面要讲的selector结合起来，有多种状态位，方便selector去识别。通道分两类，网络读写（selectableChannel)和文件操作(FileChannel)。

#### Selector 多路复用选择器

​		多路复用选择器提供选择已经就绪的任务的能力，也就是selector会不断轮询注册在其上的通道(Channel)，如果某个通道发生了读写操作,这个通道处于就绪状态，会被selector轮询出来,然后通过selectionKey可以取得就绪的Channel集合，从而进行后续的IO操作。一个多路复用器(Selector)可以负责成千上万个Channel，没有上限，这也是JDK使用epoll代替了传统的selector实现，获得连接句柄没有限制。这也意味着我们只要一个线程负责selector的轮询，就可以接入成千上万个客户端,这是JDK，NIO库的巨大进步。

### AIO

1. 异步非阻塞式IO，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。 
2. 当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。 
3. 线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做IO操作完成或者失败。
4. AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。

### Unix五种I/O模型

**阻塞I/O**：网络编程中读取客户端的数据需要调用recvfrom，内核准备好数据，并将数据从内核拷贝到用户内存后，内核返回结果，用户进程解除阻塞状态，调用会一直阻塞到数据接收完毕。

**非阻塞I/O**：用户进程调用recvfrom后，若内核数据未准备好，直接返回未准备好的结果，不阻塞用户进程，之后不断调用recvfrom轮询内核是否准备好数据。

**信号驱动I/O**：用户进程调用recvfrom后，不等待数据就绪，立即返回，待内核准备好数据之后，发送信号给用户进程，告诉用户可以开始一个I/O操作了，此时数据在内核缓冲区。

**异步I/O**：用户进程调用recvfrom后，读取操作通知内核进行读取操作并将数据拷贝至进程中，完事后内核通知进程整个操作全部完成，进程通过调用绑定的回调函数处理数据，此时I/O操作已完成，数据在用户空间中。

**I/O多路复用**：可处理多个连接，调用select后进程被select阻塞，内核空间内select监听指定的多个socket连接，当其中任意一个数据就绪即返回，程序再进行数据读取操作，将数据拷贝至当前进程中。

## 网络模型

### OSI参考模型

​		Open System Interconnection，开放系统互连参考模型。

**应用层**：考虑两个终端之间的数据交换问题，允许访问OSI环境的手段。应用协议数据单元APDU。FTP、DNS、HTTP、SMTP、WWW、NFS、Telent

**表示层**：把信息转换成计算机能识别的数据，对接收的数据进行解释、加密、解密、压缩、解压缩等。表示协议数据单元PPDU。JPEG、MPEG、ASII

**会话层**：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路，建立、管理和终止会话。会话协议数据单元SPDU IP/MAC/主机名。NFS、SQL、NETBIOS、RPC

**传输层**：定义传输数据的协议和端口号，将接收的数据进行分段和传输，到达目的地后再重组。该层的数据称为段segment，提供端到端的可靠报文传递和错误恢复，段Segment。TCP、UDP、SPX

**网络层**：将接收的数据进行IP地址的封装与解封装，该层工作设备为路由器，负责数据包从源到宿的传递和网际互连，包PackeT。用来处理在网络上流动的数据包。协议是IP协议，又分为IPv4和IPv6两种。IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、

**数据链路层**：将接收的数据进行MAC地址的封装和解封装，该层的工作设备为交换机。该层的数据称为帧。MAC地址在计算机出厂时已确定。将比特组装成帧和点到点的传递，用来处理网络的硬件部分，如硬件驱动，网卡，光纤等。PPP、FR、HDLC、VLAN、MAC 。网桥，交换机。

**物理层**：定义物理设备的标准，如网线接口类型、网线接口类型、传输介质的传输速率。传输比特流，即将0和1转化为电流强弱进行传输，到达目的地后再转化为0和1，称为数模转换与模数转换。该层的数据称为比特。物理层之间通过IO流传输数据。比特Bit。RJ45、CLOCK、IEEE802.3。中继器、集线器

### TCP/IP参考模型

​		Transmission Control Protocol/Internet Protocol。

**应用层**：HTTP/FTP

**传输层**：TCP/UDP

**网络层**：IP、ARP(IP->MAC)、RARP(MAC->IP)

**主机至网络层（数据链路层）**：

## 协议

### 数据链路层

#### ARP 地址解析协议

1. 每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
2. 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。
3. 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。 
4. 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。
5. 广播发送ARP请求，单播发送ARP响应。

#### RARP 逆地址解析协议

​		作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。

### 网络层协议

#### IP

##### IP数据报传输的过程

1. 无论怎么传，IP源和目的地址不变，但 MAC 目的和源地址会变。
2. IP 数据报需从主机 A 上传送到主机 B 上，主机 A 首先查找路由表。
    1. 若目的主机是与自己在同一个网段内，主机 A 查询自己的 ARP 表，如果存在目的IP地址到 MAC 的映射，将 MAC 地址作为目的 MAC地址封装成帧，发给主机 B；如果没有，发送 ARP 请求广播给网段内的所有主机，来查询该目的 IP地址的 MAC 地址。
    2. 若发现了能与目的网络号相匹配的表目，则把报文发给该路由表目指定的下一站的路由器或直接连接的网络接口。报文发送到下一站时，数据帧的目的 MAC 地址是下一个站路由器或者网络接口的 MAC 地址，而 IP 头部的目的 IP地址是主机 B 的 IP 地址。
    3. 否则寻找标为默认的表目，把报文发送给该表目指定的下一站路由器。

### 传输层协议

#### UDP

1. 将数据源地址和目的地地址封装成64k内的数据包，传输量小，速度快。
2. 传输不需建立连接，不可靠协议。
3. 不对数据报进行检查与修改，无须等待对方的应答，会出现分组丢失、重复、乱序。
4. 具有较好的实时性，UDP段结构比TCP的段结构简单，因此网络开销也小。
5. 常用于即时通信、语音、直播等场景

##### UDP对应的协议

1. DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
2. SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
3. TFTP(Trival File Traner Protocal)，是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。简单文件传输协议，该协议在熟知端口69上使用UDP服务。

#### TCP

1. 将数据源地址和目的地地址封装成数据包，传输量大，效率低。
2. 传输需3次握手前需建立连接，形成传输数据的通道，流传输，需4次挥手断开连接，可靠协议。
3. 有确认应答、超时重传、滑动窗口、拥塞控制等机制确保传输数据的正确性，不会出现丢失或乱序。
4. 常用于对网络通信质量有高要求的地方，如文件传输、邮件发送、远程登录等场景。

##### TCP对应的协议

1. FTP：定义了文件传输协议，使用21端口。
2. Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。
3. SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。
4. POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。
5. HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。默认端口：80

##### TCP建立连接

```
SYN：synchronization，SYN=1表示这是个连接请求，报文不携带数据，但要消耗1个序号。
ACK：表示这是个确认报文，表示已收到连接请求。
seq：sequeue，数据包本身的序列号，TCP传输报文是以字节流的形式，每个字节有序号，确保字节均发送，保证可靠性。
ack：期望对方继续发送的那个数据包的序列号
```

1. 第一次发送建立连接请求：client-->server，发送TCP连接请求数据包，SYN=1，ACK=0，seq=x，客户端进入syn_sent状态，等待回复。

    ```
    未连接队列：服务器维护一个未连接队列，该队列为每个客户端的SYN包（SYN=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入 ESTABLISHED状态。
    ```

2. 第二次发送建立连接请求：服务端server accept 客户端client的请求之后，向client端发送连接确认包，SYN=1，seq=y，ACK=1，ack=x+1，服务端进入syn_rcvd状态，表示收到请求，等待回复。

    ```
    ack=x+1：服务端上次收到的来自客户端的请求报文序号是x，所以希望客户端下次从x+1号开始发
    ```

3. 第三次发送建立连接请求：client向server发送，对第二次握手消息的确认数据包，ACK=1，ack=y+1，seq=x+1，双方进入ESTABLISHED状态，之后client和server就开始通讯了。

    ```
    seq=x+1：客户端上次收到的来自服务端的确认报文希望客户端下次从x+1开始发，所以这次就成全它
    ack=y+1：客户端上次收到的来自服务端的确认报文序号是y，所以希望服务端下次从y+1号开始发
    ```

不能两次握手的原因：

1. 若两次握手便能建立连接：客户端第一次发送的连接请求由于线路堵塞，迟迟未收到服务端的响应，以为信息丢失了，于是触发超时重传，重新发送第二次请求，成功建立连接。实际上第一次的请求并没有丢失，而是延迟到达，服务端以为是又发起的新连接，于是同意连接，成功建立连接，但实际上客户端对于这次连接并不会传输数据，服务端却一直监听等待传输，导致资源的浪费。
2. 第一次握手，服务端知道客户端具有发送的能力。第二次握手，客户端知道服务端具有接收+发送的能力。第三次握手，服务端知道客户端有接收的能力。至少经三次握手，双方才可知对方具有发送+接收的能力，才可建立可靠的通信通道。

##### TCP断开连接

​		由于 TCP 连接是全双工的，因此每个方向都要发送关闭请求，另一方向都要确认。当一方数据发送任务完成之后，可以发送 FIN 来终止这个方向的连接。而另一方可以继续发送数据。

1. 第一次发送断开连接请求：client-->server。客户端发送请求释放连接报文，FIN=1，seq=u，客户端进入 FIN-WAIT-1 状态。
2. 第二次发送断开连接请求：server-->client。服务器收到请求，发送确认报文，ACK=1，seq=v，ack=u+1，服务器进入 CLOSE-WAIT 状态，客户端收到后进入FIN-WAIT-2状态。此时又客户端发起的FIN收到回应，完成该方向的断开。
3. 第三次发送断开连接请求：server-->client。服务器发送完数据之后，向客户端发送请求释放连接报文，FIN=1，ACK=1，seq=w，ack=u+1，服务端进入LAST-ACK 状态。
4. 第四次发送断开连接请求：cilent-->server。客户端收到请求后，发送确认报文，ACK=1，seq=u+1，ack=w+1，客户端进入 TIME-WAIT 状态，等待 2MSL 后进如 CLOSED 状态，服务器收到确认后进如 CLOSED 状态。

##### CLOSE_WAIT状态

​		服务器可能有数据未发送完毕，这段时间是继续发送数据的。

​		如果建立连接之后出现故障：TCP 有个保活计时器，通常设置为 2 小时，两小时内没有收到客户端发送的数据，服务器发送探测报文，每 75s 发送一次，10 次之后探测报文没有反应，认为出现故障，关闭连接。

##### time_wait状态

1. time_wait状态一般是client的状态，并且会占用port。有时产生在server端，由于server主动断开连接或者发生异常。
2. 首先调用close()发起主动关闭的一方，在发送最后一个ACK之后会进入time_wait的状态，处于该状态下的TCP连接不能立即以同样的四元组（客户端IP地址和端口，服务端IP地址和端口号）建立新连接，即发起active close的那方占用的local port在TIME_WAIT期间不能再被重新分配。
3. MSL值得是数据包在网络中的最大生存时间。由于TIME_WAIT状态持续时间为2MSL，第四次的确认报文可能丢失，这个状态是用来重发可能丢失的 ACK 报文，保证了TCP全双工连接的可靠终止。
4. 保证了旧TCP连接双工链路中的旧数据包均因过期（超过MSL 网络中数据最大存在时间maxinum segment lifetime）而消失，此后，就可以用相同的四元组建立一条新连接而不会发生前后两次连接数据错乱的情况。

###### 作用

1. 可靠的终止TCP连接，若处于time_wait的client发送给server确认报文段丢失的话，server将在此又一次发送FIN报文段，那么client必须处于一个可接收的状态就是time_wait而不是close状态。如果执行主动关闭的一方HOST1 不进入到TIME_WAIT状态就关闭连接那会发生什么呢？当重传的FIN消息到达时，因为TCP已经不再有连接的信息了，所以就用RST(重新启动)消息应答，导致HOST2进入错误的状态而不是有序终止状态，如果发送最后ACK消息的一方处于TIME_WAIT状态并仍然记录着连接的信息，它就可以正确的响应对等方HOST2的FIN消息了。
2. 保证迟来的TCP报文段有足够的时间被识别并丢弃，linux 中一个TCPport不能打开两次或两次以上。当client处于time_wait状态时我们将无法使用此port建立新连接，A在发送完ACK报文段后，再经过2MSL时间，就可以使本连接持续的时间所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧连接的数据。

###### 避免

​		服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态。

​		在高并发短连接的 TCP 服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量 socket 处于 TIME_WAIT 状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。正常的 TCP 客户端连接在关闭后，会进入一个 TIME_WAIT 的状态，持续的时间一般在 1~4 分钟，短时间内（例如 1s 内）进行大量的短连接，则可能出现这样一种情况：客户端所在的操作系统的 socket端口和句柄被用尽，系统无法再发起新的连接。解决方法：

```
//开启 SYN Cookies，当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭。net.ipv4.tcp_syncookies = 1

//开启重用，允许将 TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭。
net.ipv4.tcp_tw_reuse = 1 

//表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
net.ipv4.tcp_tw_recycle = 1 

//修改系默认的TIMEOUT时间
net.ipv4.tcp_fin_timeout
```

##### SYN攻击原理

​		SYN 攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。

​		配合 IP 欺骗，SYN 攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 syn 包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，正常的 SYN 请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。

​		SYN Flood 是当前最流行的 DoS（拒绝服务攻击）与 DDoS（分布式拒绝服务攻击）的方式之一，这是一种利用 TCP 协议缺陷，发送大量伪造的 TCP 连接请求，从而使得被攻击方资源耗尽（CPU 满负荷或内存不足）的攻击方式。

###### 解决方案

1. 缩短 SYN Timeout 时间，由于 SYN Flood 攻击的效果取决于服务器上保持的 SYN 半连接数，这个值=SYN 攻击的频度 x SYN Timeout，所以通过缩短从接收到 SYN 报文到确定这个报文无效并丢弃改连接的时间，例如设置为 20 秒以下（过低的 SYN Timeout 设置可能会影响客户的正常访问），可以成倍的降低服务器的负荷。

2. 设置 SYN Cookie，就是给每一个请求连接的 IP 地址分配一个 Cookie，如果短时间内连续受到某个 IP 的重复 SYN 报文，就认定是受到了攻击，以后从这个 IP 地址来的包会被一概丢弃。

    ```
    上述两种方法只能对付比较原始的 SYN Flood 攻击，缩短 SYN Timeout 时间仅在对方攻击频度不高的情况下生效，SYN Cookie 更依赖于对方使用真实的 IP 地址，如果攻击者以数万/秒的速度发送 SYN 报文，同时利用 SOCK_RAW 随机改写 IP 报文中的源地址，以上的方法将毫无用武之地。
    ```

3. 分别为启用 SYN Cookie、设置 SYN 最大队列长度以及设置 SYN+ACK 最大重试次数。SYN Cookie 的作用是缓解服务器资源压力。启用之前，服务器在接到 SYN 数据包后，立即分配存储空间，并随机化一个数字作为 SYN 号发送 SYN+ACK 数据包。然后保存连接的状态信息等待客户端确认。启用 SYN Cookie 之后，服务器不再分配存储空间，而且通过基于时间种子的随机数算法设置一个 SYN 号，替代完全随机的 SYN 号。发送完 SYN+ACK 确认报文之后，清空资源不保存任何状态信息。直到服务器接到客户端的最终 ACK包，通过 Cookie 检验算法鉴定是否与发出去的 SYN+ACK报文序列号匹配，匹配则通过完成握手，失败则丢弃。

    ```
    net.ipv4.tcp_syncookies = 1
    
    //使用服务器的内存资源，换取更大的等待队列长度，让攻击数据包不至于占满所有连接而导致正常用户无法完成握手。
    net.ipv4.tcp_max_syn_backlog = 8192
    
    //降低服务器SYN+ACK报文重试次数，尽快释放等待资源。
    net.ipv4.tcp_synack_retries = 2
    ```

##### TCP拥塞控制

传输速度影响因素：Server到Client间的带宽瓶颈、客户端接收能力限制、服务器网卡处理能力。

**拥塞congestion**：在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就会变坏。若出现拥塞时不加以控制，整个网络的吞吐量将随输入负荷的增大而下降。

![image-20200426234723309](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200426234723309.png)

**拥塞窗口**：发送方维护一个叫做拥塞窗口cwnd的状态变量，其值取决于网络的拥塞程度，且能动态变化。若网络没有出现拥塞，则拥塞窗口再增大一些，只要网络出现拥塞，窗口就减小一些。拥塞窗口是几，就能发送多少个TCP数据报文段。设置拥塞控制窗口 cwnd，在发送数据时，将拥塞窗口的大小与接收端 ack 的窗口大小做比较，取较小者作为发送数据量的上限。

**滑动窗口**：TCP通过滑动窗口的概念来进行流量控制。设想在发送端发送数据的速度很快而接收端接收速度却很慢的情况下，为了保证数据不丢失，显然需要进行流量控制， 协调好通信双方的工作节奏。滑动窗口本质上是描述接受方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来。 

**拥塞判断**：若未按时收到确认报文，即发生了超时重传。

**慢开始门限ssthresh**：发送方将拥塞窗口作为发送窗口swnd，维护一个慢开始门限ssthresh状态变量。

**拥塞控制算法**：

1. 当cwnd<ssthresh时，用慢开始算法；
2. 当cwnd>ssthresh时，改用拥塞避免算法；
3. 当cwnd=ssthresh时，慢开始/拥塞避免均可。
4. 当传输的报文段有部分丢失后，发生超时重传，发送方判断网络很可能出现了拥塞，将ssthresh值更新为发生拥塞时cwnd值的一半，将cwnd值减为1，重新开始执行慢开始算法。
5. 有时，个别报文段会在网络中丢失，但实际网络并未发生拥塞，发生超时重传，误认为发生了拥塞，将cwnd重设为1，启动慢开始算法，降低了传输效率。优化采用快重传算法，让发送方尽早知道个别报文段的丢失。

**慢开始算法**：cwnd=1，每收到一个ack，cwnd++。发送方每收到一个对新报文段的确认时，即经过一个RTT往返，就把拥塞窗口值增大一倍，呈指数增长，开始下一轮传输。当拥塞窗口增长到慢开始门限时，改用拥塞避免算法。

**拥塞避免算法**：每个传输轮次结束后，拥塞窗口只能+1，呈线性增长。并不能避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。

**快重传**：即发送方尽快进行重传，而不是等超时重传计时器超时后再重传。要求接收方不要等待自己发送数据时才进行捎带确认，而是立即发送确认。即使收到了失序的报文段也要立即发出对已收到报文段的重复确认。发送方一旦收到了3个连续的重复确认，就将相应的报文段立即重传，而不是等待该报文段的超时重传计时器超时后再重传。发送方一旦收到3个重复确认，得知现在只是发生了个别报文段的丢失，于是不启动慢开始算法，执行快恢复算法。

```
例如：12成功，返回1、2的确认。3号丢失，发送方继续发4号，接收方收到4号发现乱序了，向发送方发送重复确认3号，发送方继续发5、6号，接收方又依次返回了2个重复确认3号，此时发送方收到3个连续的对3号的重复确认，则立即重传3号，接收方收到3号报文段，返回6号的确认。1-6接收成功，没有发生超时重传，不会误以为发生了拥塞。网络吞吐量约提升20%。
```

**快恢复**：发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半，开始执行拥塞避免算法。 

##### TCP粘包

​		TCP 为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的。而 UDP 则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。

​		TCP 粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。原因可能是发送方也可能是接收方造成的。

1. 发送方原因：TCP 默认使用 Nagle 算法，将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。
2. 接收方原因：TCP 将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。

​		这样一来，如果 TCP 接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了。处理方法：发送方关闭 Nagle 算法。
接收方：接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。应用层循环读取所有的数据，根据报文的长度判断每个包开始和结束的位置。

##### 数据报文结构

1. 应用程序：
2. TCP/UDP 报文头部：
    1. TCP报文头部结构：（前 20 字节固定16）为源端口号+16 位目的端口号+32 位序号+32 位确认号+4位头部长度（单位 4 字节）+6 位保留+6 个关键字（SYN,ACK，FIN）+16 位窗口大小（指接收窗口）+16 位校验和+16 位紧急指针+最多 40 字节的选项。
    2. UDP报文头部结构：首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。
3. IP 报文头部(到这是以太网帧，46-1500)：4 位版本+4 位首部长度（单位 4 字节）+8 位服务类型+16 位总长度（字节）+16 位标识（分组）+3 位标志（是否分组）+13 为片内偏移+8 位 TTL+8 位上层协议+16 位首部检验和+32 位源 IP 地址+32 位目的 IP 地址。
    以太网头部：
4. 以太网头部：6 字节目的地址+6 字节源地址+2 字节类型。这个地址指 MAC 地址。

### DNS域名解析服务器

​		一台计算机，通过ISP接入了互联网，那么ISP就会给我分配一个DNS服务器，这个DNS服务器不是权威服务器，而是相当于一个代理的dns解析服务器，他会帮你迭代权威服务器返回的应答，输入域名后通过映射解析为IP地址，然后把最终查到IP返回给你。

#### 解析域名流程

​		一旦有一步成功，则解析结束：

1. 搜索浏览器自身的DNS缓存

2. 搜索操作系统自身的DNS缓存

3. 读取hosts文件  //Hosts是一个没有扩展名的系统文件，主要作用是定义IP地址和主机名的映射关系，是一个映射IP地址和主机名的规定。

4. 向本地配置的首选DNS服务器发起域名解析请求

5. DNS拿到请求后，先检查一下自己的缓存中有没有这个地址，有的话就直接返回。这个时候拿到的ip地址，会被标记为非权威服务器的应答。

6. 如果缓存中没有的话，DNS会从配置文件里面读取13个根域名服务器的地址（这些地址是不变的，直接在BIND的配置文件中）

7. 向其中一台发起请求。

8. 根服务器拿到这个请求后，知道他是com.这个顶级域名下的，所以就会返回com域中的NS记录，一般来说是13台主机名和IP。

9. 然后DNS向其中一台再次发起请求，com域的服务器发现你这请求是baidu.com这个域的，我一查发现了这个域的NS，那我就返回给你，你再去查。

10. DNS不厌其烦的再次向baidu.com这个域的权威服务器发起请求，baidu.com收到之后，查了下有www的这台主机，就把这个IP返回给你了，

11. DNS拿到了之后，将其返回给了客户端，并且把这个保存在高速缓存中。

例如：

​		假定域名为m.xyz.com的主机想知道另一个主机y.abc.com的IP地址。例如，主机m.xyz.com打算发送邮件给y.abc.com。这时就必须知道主机y.abc.com的IP地址。整个查询过程共用到了8个UDP报文。查询步骤：

1. 主机m.abc.com先向本地服务器dns.xyz.com进行递归查询。
2. 本地服务器采用迭代查询。它先向一个根域名服务器查询。
3. 根域名服务器告诉本地服务器，下一次应查询的顶级域名服务器dns.com的IP地址。
4. 本地域名服务器向顶级域名服务器dns.com进行查询。
5. 顶级域名服务器dns.com告诉本地域名服务器，下一步应查询的权限服务器dns.abc.com的IP地址。
6. 本地域名服务器向权限域名服务器dns.abc.com进行查询。
7. 权限域名服务器dns.abc.com告诉本地域名服务器，所查询的主机的IP地址。
8. 本地域名服务器最后把查询结果告诉m.xyz.com。

### HTTP 超文本传输协议

​		HyperText Transfer Protocol，TCP/IP协议族的一个应用层协议。用于定义WEB浏览器与WEB服务器之间交换数据的过程及数据本身的格式。浏览器通过http协议与服务器进行交互。

#### 版本

HTTP1.0：

1. 短连接，每次发送请求都需三次握手建立连接。
2. 主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准。
3. Host 头处理上，1.0 请求的 url 并没有传递主机名(服务器与 IP 地址绑定)。

HTTP1.1：

1. 默认开启长连接，在一个 TCP 连接上可以传送多个 HTTP请求和响应。发送请求建立了三次握手后，该连接会维持一段时间。这段时间内可直接再次发送请求，不需再次三次握手。

2. 引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
3. 请求和响应都支持 Host 头域(虚拟主机共享 IP 地址)。
4. 新增 24 个错误状态响应码。409：请求的资源和资源的当前状态冲突。410：服务器资源永久性删除。
5. 允许只请求资源的某个部分。

HTTP 2.0：

1. 版本1.x的解析是基于文本的，而 2.0 的协议解析是采用二进制格式。
2. 多路复用，即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request。
3. header压缩。
4. 服务端推送。

#### 事务

​		http事务=请求命令+响应结果

#### 请求报文

请求行：一行，请求方式+资源名称+HTTP版本号。

请求头：多个，key: value形式。客户端在请求消息中向服务器传递附加信息。字段名不区分大小写。各行消息头排序不分先后。允许客户端在值部分指定多个可接受的选项，多个选项之间用逗号隔开。

请求正文：http要传输的内容，请求头与正文之间用一行空行隔开。

##### 请求方式

GET：明文传输。请求数据以key=value的形式拼接在URL中，多个以&隔开，URL 编码采用ASCII 编码，没有请求正文。数据大小有限制，一般不超过1k。主要用于获取特定的资源。默认的请求方式。Get 请求的资源会被浏览器缓存，get 请求直接发送请求头和数据。

POST：明文传输。请求数据放在正文body中，数据大小无限制。主要用于向指定资源提交数据。post 比 get 慢，因为 post 在发送数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据。

#### 响应报文

状态行：一个。HTTP版本号、状态码、原因叙述。表示服务器对请求的各种不同处理结果和状态。

消息头：多个，key: value形式。

响应正文：http要传输的内容，请求头与正文之间用一行空行隔开。

#### 状态码

1xx：指示信息。表示请求已接收，继续处理。

​		100：客户端必须继续发出请求 

​		101-客户端要求服务器转换 HTTP 协议版本。

2xx：成功。表示请求已被成功接收、理解、接受。

​		200：正常，成功接收请求并已完成整个处理过程。

​		204：请求收到，但返回信息为空。

​		206：分段的请求OK，服务器已经完成部分GET请求。

3xx：重定向。请求的资源已经移动一个新地址，返回一个响应头location，接重定向的url。

​		300：请求资源在多处可得到。

​		301：永久重定向，隐式重定向。

​		302：临时重定向，显示重定向。

​		304：请求的资源没有改变，可以使用缓存，无需到服务器请求。

4xx：客户端错误。请求有语法错误或请求无法实现。

​		400：服务器不支持这种请求方式。

​		401：未授权。

​		403：禁止访问。

​		404：资源不存在。

​		409：对当前资源状态，请求不能完成。

5xx：服务器端错误。服务器未能实现合法的请求。

​		500：资源存在，服务端程序出错。

​		501：未实现。

​		502：网关错误。

​		503：服务不可用。

​		504：网关超时。

### HTTPs

1. HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费。 
2. HTTP 协议运行在 TCP 之上，传输的内容都是明文。HTTPS 运行在 SSL/TLS(运行在 TCP 之上)之上，内容加密。 
3. 连接端口不一样，http 是 80，https 是 443。
4. http 连接简单，没有状态，https 是 ssl 加密的传输，身份认证的网络协议，更安全。 

#### 对称加密

​		客户端和服务端采用相同的密钥进行加密解密。encrypt(明文，秘钥)=密文，decrypt(密文，秘钥)=明文 。

#### 非对称加密

​		密钥成对出现，分为公钥和私钥，公钥和私钥之间不能互相推导，公钥加密需要私钥解密， 私钥加密需要公钥解密。客户端通过公钥加密，服务端通过私钥解密。encrypt(明文，公钥)=密文 ，decrypt(密文，私钥)=明文 。

#### 加密算法

非对称加密算法：RSA，DSA/DSS 

对称加密算法：AES，RC4，3DES 

HASH 算法：MD5，SHA1，SHA256HTTP

#### SSL

​		HTTPS在传统的 HTTP 和 TCP 之间加了一层用于加密解密的 SSL/TLS 层。采用对称加密和非对称加密结合的方式来保护浏览器和服务端之间的通信安全。客户端发出的请求很容易被黑客截获，如果此时黑客冒充服务器，则其可返回任意信息给客户端，而不被客户端察觉，所以我们经常会听到一词“劫持”。而 HTTPS 实际上是带有 SSL 的 HTTP（HTTP + SSL=HTTPS）。当您在浏览器的地址栏中看到 HTTPS 时，这就意味着与该网站的所有通信都将被加密，整个访问过程更加安全。

#### 加密过程

1. 浏览器使用 Https 的 URL 访问服务器，建立 SSL 链接； 
2. 发送非对称加密的公钥 A 给浏览器2、客户端(SSL/TLS)解析证书（无效会弹出警告） 
3. 生成随机值(这个相当于传送数据的密钥)，作为对称加密的密钥 B。 
4. 浏览器使用服务器返回的公钥 A，对自己生成的对称加密密钥 B 进行加密，得到密钥 C。 
5. 浏览器将密钥 C 发送给服务器 
6. 务器使用自己的私钥 D 对接受的密钥 C 进行解密，得到对称加密密钥 B。 
7. 将信息和密钥 B 混合在一起进行对称加密 
8. 将加密的内容发送给客户端 
9. 客户端用密钥 B 解密信息 

#### 验证证书

1. 客户端获取到了站点证书，拿到了站点的公钥 
2. 客户端找到其站点证书颁发者的信息 
3. 站点证书的颁发者验证服务端站点是否可信 



## 请求处理过程

1. 域名解析，获取域名的IP地址，使用DNS协议。
2. 发起TCP的三次握手，与服务器建立TCP连接，使用TCP协议。建立TCP协议时需发送数据，在网络层用到IP协议。IP数据包在路由间传送，路由选择使用OPSF协议。路由器与服务器通信时，将IP地址转化为MAC地址，使用ARP协议。
3. 发起HTTP请求，发送http请求报文，使用HTTP协议。
4. 服务器响应HTTP请求，回复http响应报文，即html代码。
5. 浏览器解析HTML代码。当遇到JS/CSS/图片等静态资源时，自动向服务器端再次发送请求下载。
6. 浏览器将HTML代码和静态资源对页面进行渲染并呈现给用户

**客户端HTTP层**：监听着某一端口的connector接收到对应的请求，connector内维护了engine的索引，域名解析，得到请求访问的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPDNS缓存，根域名服务器。生成请求报文，将请求报文封装成request对象，同时生成一个空的response对象。传输给TCP层的engine。

**客户端TCP层**：engine内维护了host的索引，engine找到对应的主机名，将HTTP层的请求报文分割成报文段，将IP地址的剩余部分传输给IP层的host。

**客户端IP层**：host内维护了应用的索引，host找到对应的应用名，将请求发送给应用。

**客户端应用层**：应用中有多个组件，根据请求的URL，查看是否有filter能处理该请求，将所有能处理该请求的filter按一定顺序规则串成过滤链。先经由Filter过滤链处理或拦截，选择对应的Servlet或JSP处理请求，检查是否有servlet实例对象，若有则直接使用，若无则创建。默认为第一次发送请求时创建servlet对象。若设置了load-on-startup，则项目启动时自动创建servlet实例对象。servlet执行完毕后，依次执行chain.doFilter()后面的代码。

**客户端链路层**：包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包进行传输，发送IP数据包到服务器的IP地址。

**接收方的IP层**

**接收方的TCP层**：按序号按格式拼接成请求报文

**接收方的HTTP层**：解析请求报文，封装成request对象。用Tomcat默认的DefaultSevlet处理该request。若资源存在，则以流的形式写入到response对象中，若资源不存在，404。connector读取response中的数据，拼出响应报文，传给TCP层。

## Cookie

### 会话

​		用户打开一个浏览器，点击多个超链接，访问同一个服务器多个web资源，然后关闭浏览器，整个过程称之为一个会话。

### 无状态协议

​		Web应用程序是使用HTTP协议传输数据的，HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制：cookie。

### Cookie

​		Cookie是客户端(浏览器)技术，实际上是一小段的文本信息。由于服务器无法从http协议上分辨不同的用户，服务器程序把每个用户的数据以设置response响应头cookie的形式写给用户各自的浏览器，客户端浏览器会把Cookie保存起来。当用户使用浏览器再去访问服务器中的web资源时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，便能识别用户状态了，web资源处理的就是用户各自的数据了，服务器还可以根据需要修改Cookie的内容。这就是Cookie的工作原理。

​		不同浏览器间不共享数据。只能存储字符串，大小有限制。没有专门的API删除cookie，将最大时效设为0则是命令浏览器删除该cookie。

## Session

​		当浏览器第一次访问时，服务器会创建一个session对象，会生成一个随机ID，作为其唯一标识。将该ID通过cookie的形式返回给浏览器端，key=JSessionID，value=该session的ID。

​		浏览器再次访问服务器时，会带上该cookie请求头，遍历cookie，取出含有JSessionID的cookie，用cookie传输session的ID，服务器可以取出其中的ID，找到对应的session对象，就可以跟踪会话了。如果浏览器不支持 cookie，可以用 url 重写的方式，将 sessionId 写入 url 传给服务器。HttpServletResponse 接口提供了重写 URL 的方法：`public java.lang.String encodeURL(java.lang.String url)` 。该方法的实现机制为： 

1. 先判断当前的 Web 组件是否启用 Session，如果没有启用 Session，直接返回参数 url。 
2.  再判断客户端浏览器是否支持 Cookie，如果支持 Cookie，直接返回参数 url；如果不支持 Cookie，就在参数 url 中加入 Session ID 信息，然后返回修改后的 url。 

### 生命周期

​		session产生之后保存在服务端内存中。当关闭浏览器，应用被卸载stop时，session对象被销毁，session中的数据会被序列化到本地硬盘的SESSION.ser文件中。当重新start时，会创建一个新的session对象，从该序列化文件中读取ID和数据赋值给该新的session对象，进行反序列化。

### 数据销毁时机

1. 主动调用session.invalidate()方法
2. session的有效期到。默认30min，若该时间内无人访问session对象，则session失效。可通过Tomcat的conf/web.xml配置文件修改全局性的session有效时间。

### URL重写

​		Session依赖于cookie，若浏览器禁用了cookie，则需用到URL重写。在每个页面中的每个链接和表单中都添加名为jSessionId的参数，值为当前sessionid。当用户点击链接或提交表单时也服务器可以通过获取jSessionId这个参数来得到客户端的sessionId，找到sessoin对象。或者使用response.encodeURL()对每个请求的URL处理，这个方法会自动追加jsessionid参数，该方法会判断客户端浏览器是否禁用了Cookie，如果禁用了，那么这个方法在URL后面追加jsessionid，否则不会追加。

## Servlet

​		开发动态web资源的技术。编写一个Java类，实现servlet接口，把开发好的Java类部署到web服务器中，即可由java程序向浏览器输出数据。Servlet单实例多线程。

```
//常用包：
import javax.servlet;
import javax.servlet.http;
```

### 注册

1. web.xml配置文件中新增<'servlet>节点，<'servlet-mapping>元素把servlet程序映射到一个URL地址上。
2. 注解

### 生命周期

​		Servlet是一个供其他Java程序（Servlet引擎）调用的Java类，它不能独立运行，它的运行完全由Servlet引擎来控制和调度。针对客户端的多次Servlet请求，通常服务器只会创建一个Servlet实例对象。Servlet实例对象一旦创建，就会驻留在内存中，为后续的其它请求服务，直至web容器退出(或应用停止)，servlet实例对象才会销毁。为web应用写一个InitServlet，这个servlet配置为启动时装载，可为整个web应用创建必要的数据库表和数据。

#### 初始化阶段

​		在Servlet的整个生命周期内，Servlet的init方法只被调用一次，会创建servlet对象、servletConfig对象。若在<'servlet>元素中配置了一个<'load-on-startup>元素，设置其值为非负数，WEB应用程序在启动时，则会装载并创建Servlet的实例对象、以及调用Servlet实例对象的init()方法。

##### ServletConfig对象

​		在Servlet的配置文件中，可以使用一个或多个<'init-param>标签为某个servlet配置一些初始化参数。当servlet配置了初始化参数后，web容器在创建servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用servlet的init方法时，将ServletConfig对象传递给servlet。通过ServletConfig对象就可以得到当前servlet的初始化参数信息。可直接通过getServletConfig()得到ServletConfig对象。

##### ServletContext对象

​		WEB容器在启动时，会为每个WEB应用程序都创建一个对应的ServletContext对象，代表当前web应用。ServletConfig对象中维护了ServletContext对象的引用，可通过ServletConfig.getServletContext方法获得ServletContext对象。一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常被称为context域对象。

###### 应用

1. 获取WEB应用的初始化参数（多个serlvet获取相同参数）
2. 多个Servlet通过ServletContext对象实现数据共享
3. 实现Servlet的转发（request）

#### 运行阶段

​		对一个Servlet的每次访问请求都导致Servlet引擎调用一次servlet的service方法。对于每次访问请求，Servlet引擎都会创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象，将这两个对象作为参数传递给它调用的Servlet的service()方法，service方法再根据请求方式分别调用doXXX方法。 

#### 销毁阶段

​		释放资源

### 执行过程

1. 项目启动，创建ServletContext。
2. 读取web.xml，反射创建Listener。
3. 给ServletContext注入ServletContextListener（接口形参）。
4. 调用servletContext的init()方法，init()里面调用listener.contextInitialized()。
5. 读取web.xml，反射创建Filter。
6. 把所有的Filter放在一个FilterChain里。
7. 客户端发出请求
8. 服务器读取web.xml，反射创建Servlet。
    1. <'servlet-mapping>元素中，找到匹配的<'url-pattern>元素，由此确定servlet-name。
    2. 根据servlet-name，<'servlet>元素中找到匹配的<'servlet-class>，由此确定Servlet的类名。
    3. 到Tomcat安装目录/webapps/Demo1/WEB-INF/classes/cn/cskaoyan目录下查找HelloServlet.class文件。Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。若已创建，则直接执行第10步，否则，装载并创建该Servlet的一个实例对象。

9. 调用Servlet实例对象的init()方法
10. tomcat创建一个用于封装HTTP请求消息的HttpServletRequest对象，和一个代表HTTP响应消息的空的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。
11. 执行FilterChain中每个Filter的doFilter()方法。
12. Servlet开始处理请求，响应结果。
13. WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 

### 实现类

#### HttpServlet

​		能够处理HTTP请求的servlet，在原有Servlet接口上添加了一些与HTTP协议处理方法，因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。

​		覆写了service方法，该方法体内的代码会自动判断用户的请求方式。如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。

#### GenericServlet

### request/response

|              | 转发                                                         | 包含                                         | 重定向         | 定时刷新                 |
| ------------ | ------------------------------------------------------------ | -------------------------------------------- | -------------- | ------------------------ |
| 执行主体     | 服务器                                                       | 服务器                                       | 浏览器         | 浏览器                   |
| 执行对象     | request                                                      | request                                      | response       | response                 |
| URL          | 即使写了全路径，也只能访问当前应用下的资源。                 | 即使写了全路径，也只能访问当前应用下的资源。 | 可访问外部资源 | 可访问外部资源           |
| 请求次数     | 一次                                                         | 一次                                         | 两次           | 两次                     |
| 浏览器地址栏 | 不变                                                         | 不变                                         | 变             | 变                       |
| request域    | 共享                                                         | 共享                                         | 不共享         | 不共享                   |
| 状态码       |                                                              |                                              | 302/307        | 200                      |
| 功能         | 多个组件间共享数据                                           |                                              | 跳转至外部链接 | 具有交互性的外部链接跳转 |
| 相对路径     | 目标资源相对当前资源的路径，应用名可用getContextPath()动态获取。 | 同                                           | 同             | 同                       |
| /开头路径    | /资源名                                                      | /资源名                                      | /应用名/资源名 | /应用名/资源名           |

### 缺省servlet

​		如果某个Servlet的映射路径仅仅为一个正斜杠（/），那么这个Servlet就成为当前Web应用程序的缺省Servlet。 凡是在web.xml文件中找不到匹配的<'servlet-mapping>元素的URL，它们的访问请求都将交给缺省Servlet处理。

​		在<tomcat的安装目录>\conf\web.xml文件中，注册了一个名称为org.apache.catalina.servlets.DefaultServlet的Servlet，并将这个Servlet设置为了缺省Servlet。当访问Tomcat服务器中的某个静态HTML文件和图片时，实际上是在访问这个缺省Servlet。

### 域

#### context域

​		当前应用下所有的资源共享其中的数据，不受浏览器限制，通过setAttribute直接替换。

#### session域

​		当前应用下的同一个浏览器共享数据，受浏览器限制。

#### request域

​		request对象中有一个map，可用来存取数据。同一个request对象共享request域中的数据，但每次访问都会创建新的request对象，可用转发和包含操作实现共享这个request域。

## JSP

​		JSP本质为servlet。conf/web.xml中有一个名为jsp的servlet，其url-pattern为*.jsp，当访问某个jsp文件时，请求会被该名为jsp的servlet处理。

### 执行过程

1. 根据jsp的名称生成对应的java文件jsp名_jsp.java
2. 翻译成java文件时，会将jsp语法中的一些表达式转换成对应的Java代码。
3. 编译成class字节码文件
4. 调用相应的service方法
5. 将html代码发送给浏览器端

###  <%!

​		<%! … ％>之间声明的变量和方法在整个JSP页面内都有效，但方法内定义的变量只在方法内有效。JSP引擎将JSP页面转译成 Java 文件时，将这些变量作为类的成员变量，这些变量的内存空间直到服务器关闭才被释放。

​		当多个客户请求一个JSP页面时，JSP引擎为每个客户启动一个线程，这些线程由 JSP 引擎服务器来管理。这些线程共享JSP页面的成员变量，因此任何一个用户对 JSP页面成员变量操作的结果，都会影响到其他用户。

### <%--

​		注释

### <%

​		脚本片段，编写多行Java代码，每行用分号隔开。

### <%@

​		引入其它JSP页面，如果使用include指令引入了其它JSP页面，那么JSP引擎将把这两个JSP翻译成一个servlet。<%@ include file=“被包含组件的绝对URL或相对URL"%>，其中的file属性用于指定被引入文件的路径，路径以“/”开头，表示代表当前web应用。被引入的文件必须遵循JSP语法，可以使用任意的扩展名，即使其扩展名是html，JSP引擎也会按照处理jsp页面的方式处理它里面的内容。JSP规范建议使用.jspf（JSP fragments）作为静态引入文件的扩展名，include指令引入通常也称之为静态引入。由于使用include指令将会涉及到2个JSP页面，并会把2个JSP翻译成一个servlet，所以这2个JSP页面的指令不能冲突（除了pageEncoding和导包除外）。

### 内置对象

**request**：HttpServletRequest

**response**：HttpServletResponse

**config**：ServletConfig

**application**：ServletContext

**Session**：HttpSession。访问index.jsp会自动创建session，因为jsp九大对象里有session，访问html或servlet时需request.getSession()才会创建session。

**out**：<%= … %>，其中的内容相当于嵌套在out.print()中，本质是JSPWriter对象，将数据先存入JSPWriter对象的缓冲区，当out对象的缓冲区已满，或整个JSP页面结束 ，再将该缓冲区中的数据存入response缓冲区，显示到页面。当设置page指令的buffer属性为none，不使用JspWritere的缓冲区，关闭out对象的缓存功能。设置buffer的大小，可以更改JspWriter缓冲区的大小。

**exception**：Throwable。当设置isErrorPage="true"时，可以使用Exception对象。当isErrorPage ="false"时，用errorPage="error.jsp"(isErrorPage默认是false)设置当前页面要引入错误的页面，该错误页面error.jsp一定要有isErrorPage属性且值为 true。

**page**：this Object。<%@ 指令 属性名="值"%>，用于定义JSP页面的各种属性，无论page指令出现在JSP页面中的什么地方，它作用的都是整个JSP页面。page指令最好是放在整个JSP页面的起始位置。

**pageContext**：代表JSP页面的运行环境，其自身还是一个域对象，可用来保存数据。该对象封装了对其它8大隐式对象的引用，还封装了获取其它域对象中的属性或进行赋值的方法，作用范围为当前页面。

### include

#### 静态include

1. 用 include 伪码实现，<%@ include file="included.htm" %> 。
2. 不会检查所含文件的变化，适用于包含静态页面。 
3. 在翻译阶段执行
4. 引入静态文本 (html,jsp)，在 JSP页面被转化成 servlet 之前和它融和到一起，即先将文件的代码原封不动地加入到主页面从而合成一个文件，再进行翻译，此时不允许有相同的变量。

#### 动态include

1. 用 jsp:include动作实现，<jsp:include page="included.jsp" flush="true" /> 。
2. 会检查所含文件中的变化，适用于包含动态页面 , 并且可以带参数。
3. 在请求处理阶段执行
4. 引入执行页面或servlet所生成的应答文本，即各个文件分别先编译，然后组合成一个文件。

## Listener

​		Listener不是Servlet。任何Listener本质上都是接口回调。用于监听Web常用域对象HttpServletRequest，HttpSession，ServletContext等的生命周期以及属性变化（添加，删除，替换等）。

### 实现

​		实现ServletContextListener接口。在web.xml配置文件中注册该接口，或者在注解中注册该接口。当Tomcat启动时会读取注册的信息，创建对应的实现对象。

###  应用

1. 统计在线人数

###  回调函数

​		通过函数参数传递到其它代码的，某一块可执行代码的引用。为多态的使用。

## Filter

​		由servlet容器调用，拦截或处理request对象和response对象。在与过滤器关联的Servlet被调用之前检查并且修改request对象，在与过滤器关联的Servlet调用之后检查并修改response对象。

​		filter是一个可以复用的代码片段，可以用来转换HTTP请求、响应和头信息。Filter和Servlet极其相似，区别只是Filter不能直接对用户生成响应，它只是修改对某一资源的请求，或者修改从某一的响应。 doFilter()方法里的代码就是从多个Servlet的service()方法里抽取的通用代码，通过使用Filter可以实现更好的复用。 

###  生命周期

​		随着应用的创建而创建，随着应用的销毁而销毁。

### 实现

1. 无现成实现类，需实现接口，重写三个方法。

**init(FilterConfig config)**：项目启动时执行，FilterCondig对象可获取初始化的参数。

**doFilter(ServletRequest request,ServletResponse response,FilterChain chain)**：request请求对象包括表单数据、Cookie、HTTP请求头等信息。response响应对象用于响应request对象访问的信息。chain调用过滤器链中的下一个资源，将request和response两个对象传递给下一个过滤器或其他的Servlet/JSP等资源。

**destroy()**：应用关闭时销毁

2. 修改web.xml配置文件，注册<'filter>节点。

3. <'filter-mapping>中通过url-pattern与servlet产生关联，可以有多个url-pattern，默认情况下与servlet关联后直接拦截。

### 执行顺序

若有多个filter可以同时处理某个请求，将所有可执行的filter按相关顺序串起来，按顺序将所有的chain.doFilter()执行完，直到执行到servlet。再按相反的顺序执行完所有filter的chain.doFilter()方法后面的部分。其执行的顺序为：

1. 配置文件节点方式：web.xml中filter-mapping声明的先后顺序
2. 注解方式：以类名的首字母ACSII表先后顺序
3. web.xml和注解同时存在时，优先执行web.xml。

## Json

​		Json是轻量级的数据交换格式。xml通过文档模型解析，需遍历节点。Json不需要有严格的闭合标签，使得有效数据量与总数据包比大大提升，从而减少同等数据流量的情况下网络的传输压力。

## 架构

### MVC设计模式

controller：判断、转发

model：封装数据和基于对这些数据的方法，如登录、注册、修改密码等。

view：视图。对于传统的非前后端分类的项目，JSP作为view。对于前后端分类的项目，直接以json字符串的形式传给前端。

### 三层构架

​		解耦，每层之间的依赖度非常低，代码需要变动时，其他层代码无需更改。利于团队开发，便于维护管理。

controller层：servlet层，请求到达controller层，接收用户输入的数据，进行数据的校验、分发、从model中取出数据交由view显示。

service层：具体的业务逻辑层，处理复杂项目中不适合在controller层或dao层中实现的逻辑。

dao层：data access object，数据处理层，封装一些与数据库打交道的API。

#### 事务

​		获取当前线程，每个线程中有一个map容器ThreadLocalMap，不同线程之间不共享该map中的数据。该map的key是当前线程的ThreadLocal对象，value是set()方法set进去的值，该map只允许设置一次value，get()方法get出来的是当前线程的ThreadLocal对象的value。不同线程之间ThreadLocal中的数据相互隔离，在ThreadLocal对象中set一个connection对象，service层和dao层是一个线程，所以会是同一个ThreadLocal对象，便可以共享connection，起到事务的作用。