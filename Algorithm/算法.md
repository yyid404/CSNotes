# 算法

## 排序

| 排序方法     | 平均时间复杂度 | 最坏时间复杂度 | 最好时间复杂度 | 空间复杂度 | 稳定性 |
| ------------ | -------------- | -------------- | -------------- | ---------- | ------ |
| 直接插入排序 | O(n^2)         | O(n^2)         | O(n)           | O(1)       | 稳定   |
| 选择排序     | O(n^2)         | O(n^2)         | O(n^2)         | O(1)       | 不稳定 |
| 快速排序     | O(n·log2n)     | O(n^2)         | O(n·log2n)     | O(n·log2n) | 不稳定 |
| 冒泡排序     | O(n^2)         | O(n^2)         | O(n)           | O(1)       | 稳定   |
| 希尔排序     | O(n·log2n)     | O(n^2)         | O(n)           | O(1)       | 不稳定 |
| 归并排序     | O(n·log2n)     | O(n·log2n)     | O(n·log2n)     | O(n)       | 稳定   |
| 基数排序     | O(d(n+r))      | O(d(n+r))      | O(d(n+r))      | O(n+r)     | 稳定   |
| 堆排序       | O(n·log2n)     | O(n·log2n)     | O(n·log2n)     | O(1)       | 不稳定 |

### 直接插入排序

> Straight Insertion Sorting。在要排序的一组数中，假设前面(n-1) [n>=2] 个数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。将后部分元素逐一与前部分元素比较，如果前部分元素比array[i]小，就将前部分元素往后移动。当没有比array[i]小的元素，即是合理位置，在此位置插入array[i]。
>
> 折半插入排序：折半查找出元素的待插入位置，统一移动待插入位置后的所有元素。

> ```java
> void insertSort(int [] arr){
> 	int len=arr.length;//单独把数组长度拿出来，提高效率
> 	int insertNum;//要插入的数
> 	for(int i=1;i<len;i++){//因为第一次不用，所以从1开始
> 		if (arr[i]<arr[i-1]){
> 			insertNum=arr[i];
> 			int j=i-1;
> 			while (j>=0 && arr[j]>insertNum){//从后往前循环，将大于insertNum的数向后移动
> 				arr[j+1]=arr[j];
> 				j--;
> 			}
> 			arr[j+1]=insertNum;//找到位置，插入当前元素
> 		}
> 	}
> }
> ```

### 选择排序

> 每一趟从待排序序列选择一个最小的元素放到已排好序序列的末尾，剩下的为待排序序列，每一趟确定一个当前最小元素的位置，重复上述步骤直到完成排序。

> ```java
> void selectSort(int[] arr) {
> 	int len=arr.length;
> 	for(int i=0;i<len-1;i++){
> 		int index=i;
> 		for(int j=i+1;j<len;j++){
> 			if (arr[j]<arr[index]){
> 				index=j;
> 			}
> 		}
> 		if(index!=i){//找到了比arr[i]小的则交换位置
> 			int min=arr[index];
> 			arr[index]=arr[i];
> 			arr[i]=min;
> 		}
> 	}
> }
> ```

### 冒泡排序

> 依次两两比较相邻元素的值，若为逆序，则交换两者，直到序列比较完毕，每经过一趟交换，最大的元素交换到序列的最后位置，剩下的为新的待排序序列，前面确定位置的元素不再参与比较。一趟重复上述过程直到排完所有元素。

> ```java
> void bubbleSort(int[] arr) {
> 	int len=arr.length;
> 	for(int i=0;i<len-1;i++){//n-1趟排序
> 		for(int j=0;j<len-1-i;j++){
> 			if(arr[j]>arr[j+1]){
> 				int max=arr[j];
> 				arr[j]=arr[j+1];
> 				arr[j+1]=max;
> 			}
> 		}
> 	}
> }
> ```

### 快速排序

> 基于冒泡排序，添加分治思想。任取一个元素作为基准，经过一趟排序使得基准左边全是小于它的元素，右边元素全大于基准，基准元素位置便确定。对左右两子表分别递归调用上述过程，直到每部分只含一个元素，此时所有元素都在其最终位置上。

> ```java
> void quickSort(int[]arr,int start,int end) {
> 	if(start>end){//索引不合法
> 		return;
> 	}
>     int baseNum=arr[start];//基准值
>     int i=start;//左指针
>     int j=end;//右指针
>     while(i<j){
>         while(i<j && arr[j]>=baseNum){//找到倒数第一个比基准小的值
>             j--;
>         }
>         while(i<j && arr[i]<=baseNum){//找到正数第一个比基准值大的值
>             i++;
>         }
>         int temp=arr[i];
>         arr[i]=arr[j];
>         arr[j]=temp;
>     }
>     //i和j相遇，将基准值赋给该位置
>     arr[start]=arr[i];
>     arr[i]=baseNum;
>     quickSort(arr,start,i-1);
>     quickSort(arr,i+1,end);
> }
> ```

### 希尔排序

> 取小于n的步长，根据步长分成若干组，分别在各组进行直接插入排序，逐渐取更小的步长直到为1，重复上述过程。

> ```java
> void sheelSort(int[]arr) {
>     int len=arr.length;
>     for(int gap=len/2;gap>0;gap/=2){//逐步减小增量
>         for(int i=gap;i<len;i++){
>             int j=i;
>             while(j-gap>=0 && arr[j]<arr[j-gap]){//需是短路与
>                 int temp=arr[j-gap];
>                 arr[j-gap]=arr[j];
>                 arr[j]=temp;
>                 j-=gap;
>             }
>         }
>     }
> }
> ```

### 归并排序

> 将待排序看成是n个长度为1的子表，两两归并，组内排序，得到n/2向上取整个有序表，经过log2n向上取整次归并，即合并成一个长度为n的有序表。每趟归并的时间复杂度为O(n)。

> ```java
> void mergeSort(int[] arr,int start,int end){
>     if(start>=end){//索引不合法
>         return;
>     }
>     int mid=(start+end)/2;
>     mergeSort(arr,start,mid);//递归排序左边
>     mergeSort(arr,mid+1,end);//递归排序右边
>     merge(arr,start,mid,end);//合并
> }
> 
> void merge(int[] arr,int start,int mid,int end) {
>     int[] temp=new int[end-start+1];//临时数组
>     int k=0;
>     int i=start;
>     int j=mid+1;
>     while(i<=mid && j<=end){
>         //两数组中较小者放入临时数组
>         if(arr[i]<=arr[j]){
>             temp[k]=arr[i];
>             i++;
>         }
>         else{
>             temp[k]=arr[j];
>             j++;
>         }
>         k++;
>     }
>     //将剩余的那个数组的剩余部分依次放入临时数组
>     while(i<=mid){
>         temp[k]=arr[i];
>         i++;
>         k++;
>     }
>     while(j<=end){
>         temp[k]=arr[j];
>         j++;
>         k++;
>     }
>     //将临时数组中的元素拷回原数组同范围的位置
>     for(int m=0;m<k;m++){
>         arr[m+start]=temp[m];
>     }
> }
> ```

### 基数排序

> 根据关键字各位的大小进行排序，通过分配和收集两种操作对单逻辑关键字进行排序。分为最低位优先（LSD）和最高位优先（MSD）。
>
> > 设：线性表有n个元素a0,...an-1。每个元素aj（0<=j<n）的关键字最多有d位，以d元组（）表示。取基数r（r>）大于每一位数字的最大值。
> >
> > 首先：把r个队列Q0,...Qr-1置空。
> >
> > 分配：依次检查所有元素aj的某一位i（0<=i<d），若其值等于对应队列号k（0<=k<r），就把该元素aj放入队列Qk中。
> >
> > 收集：把各队列中的元素依次首尾连接，组成新的线性表。重复：按顺序对每一位i（0<=i<d）执行上述步骤。

> ```JAVA
> void baseSort(int[] arr) {
>     //找出最大值，由其位数确定排序的趟数。
>     int max=arr[0];
>     for(int i=1;i<arr.length;i++){
>         if(arr[i]>max){
>             max=arr[i];
>         }
>     }
>     int bit=0;
>     while(max>0){
>         max/=10;
>         bit++;
>     }
>     //建10个队列存储基数0-9
>     List<ArrayList<Integer>> lists = new ArrayList<>();
>     for(int i=0;i<10;i++){
>         lists.add(new ArrayList<Integer>());
>     }
>     //bit趟分配和收集
>     for(int i=0;i<bit;i++){
>         for(int j=0;j<arr.length;j++){
>             //从低位到高位获取数字
>             int num=arr[j] % (int)Math.pow(10,i+1) / (int)Math.pow(10,i);
>             ArrayList<Integer> listN = lists.get(num);
>             listN.add(arr[j]);
>             lists.set(num,listN);
>         }
>         int index=0;
>         for(int k=0;k<10;k++){
>             while(lists.get(k).size()>0){
>                 ArrayList<Integer> listN = lists.get(k);
>                 arr[index]=listN.get(0);
>                 listN.remove(0);
>                 index++;
>             }
>         }
>     }
> }
> ```

### 堆排序

> 将n个元素看成一棵完全二叉树的顺序存储结构，以操作树的形式操作数组。用元素构造初始大顶堆，最大值即为堆顶根节点，将其与末尾元素交换，此时末尾为最大值。堆被破坏，将剩余待排序元素重新构造成堆，直到堆中只剩一个元素，即可得到有序序列。升序排序就使用大顶堆，反之使用小顶堆，原因是堆顶元素需要交换到序列尾部。
>
> 从最后一个非叶子节点开始，最后一个非叶子节点的索引为n/2向下取整-1，从右至左，从下至上，依次向前递减，逐个将以该节点为根节点的树调整成大顶堆。比较当前要调整的树的根节点的左右孩子节点，左孩子索引为父节点索引*2+1，若左右孩子节点的最大值比当前节点大，则将其与当前节点交换。交换后可能会破坏子树的堆，继续操作子树。每构建成功1次，将堆顶元素移至数组末尾，当前待排元素最大值归位，待排元素个数-1。

> ```java
> void heapSort(int[] arr){
>     int len=arr.length;
>     while(len>0){
>     //从最后一个非叶子节点开始，从右至左，从下至上，逐个将以该节点为根节点的树调整成大顶堆
>     for (int i=len/2-1;i>=0;i--){//最后一个非叶子节点的索引为n/2向下取整-1
>         heapAdjust(arr, i,len);
>     }
>     //每构建成功1次，将堆顶元素移至数组末尾，当前待排元素最大值归位，待排元素个数-1
>     swap(arr,0,len-1);
>     len--;
>     }
> }
> 
> void heapAdjust(int[] arr,int index,int len){
>     int temp=arr[index];
>     //从当前要调整的树的根节点的左孩子开始，左孩子索引为父节点索引*2+1，调整后可能会破坏子树，所以执行完一次循环条件*2+1即为子树的左孩子
>     for(int i=index*2+1;i<len;i=i*2+1){
>         if(i+1<len){
>             if(arr[i+1]>arr[i]){
>                 i++;
>             }
>         }
>         if(arr[i]>temp){
>             swap(arr,i,index);
>             index=i;
>             temp=arr[i];
>         }
>     }
> }
> 
> void swap(int[] arr,int i,int j){
>     int temp=arr[i];
>     arr[i]=arr[j];
>     arr[j]=temp;
> }
> ```

### 最小的k个数

> 剑指Offer-40
>
> 输入整数数组 `arr` ，找出其中最小的 `k` 个数。
>
> > 例如：输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

#### Solution1. 大根堆

> 1. 借助Java的PriorityQueue优先队列该数据结构，底层是堆排序实现的，默认是小顶堆，添加 comparator参数使其变成最大堆。
> 2. 大顶堆堆顶元素是最大值，遍历数组，若当前元素比堆顶小，则移除堆顶元素，这样最后堆中的元素即为最小的k个数。
> 3. 时间复杂度：O(NlogK)。遍历数组需要O(N)，每次与堆中的元素比较需要O(logK)。
> 4. 由于使用了一个大小为 k 的堆，空间复杂度为 O(k)*O*(*k*)；

> ```java
> class Solution{
>     public int[] getLeastNumbers(int[] arr, int k) {
>         if(k==0 || arr.length==0) return new int[]{};
>         /*
>         PriorityQueue<Integer> heap = new PriorityQueue<>(new Comparator<Integer>() {
>             @Override
>             public int compare(Integer n1, Integer n2) {
>                 return n2-n1;
>             }
>         });
>         */
>         PriorityQueue<Integer> heap = new PriorityQueue<>((n1,n2) -> n2-n1);
>         for (int num : arr) {
>             if (heap.size()<k) heap.offer(num);
>             //当前元素比堆顶元素小，且堆满，弹出堆顶。
>             else if (num<heap.peek()) {
>                 heap.poll();
>                 heap.offer(num);
>             }
>         }
>         //return heap.stream().mapToInt(Integer::intValue).toArray();
>         int[] result=new int[k];
>         int index=0;
>         for (Integer n : heap) {
>             result[index++]=n;
>         }
>         return result;
>     }
> }
> ```

#### Solution2. 快排变形

> 1. 快速排序思想中的partition划分操作，从数组中随机选取一个枢纽元素m，然后原地移动数组中的元素，使得比m小的元素在m的左边，比m大的元素在m的右边。
>
> 2. 快速排序会递归地排序左右两侧的数组。而快速选择quick select算法的不同之处在于，接下来只需要递归地选择一侧的数组。
>
> 3. 假设经过一次partition操作，枢纽元素的索引为m：
>
>     > 1. 若m=k，则数组左边m个元素即为最小的k个元素。
>     > 2. 若m<k，则最小的k个数一定都在m的左侧，对左侧数组递归调用parition函数。
>     > 3. 若m>k，则左侧数组中的m个数都属于最小的k个数，还需在右侧数组中寻找最小的k-m个数，对右侧数组递归调用parition函数。
>
> 4. 优劣：
>
>     > 1. 该算法需要修改原数组，如果原数组不能修改的话，还需要拷贝一份数组，空间复杂度就上去了。
>     > 2. 如果把数据看成输入流的话，使用堆的方法是来一个处理一个，不需要保存数据，只需要保存 k 个元素的最大堆。而快速选择的方法需要先保存下来所有的数据，再运行算法。当数据量非常大的时候，甚至内存都放不下的时候，就麻烦了。所以当数据量大的时候还是用基于堆的方法比较好。
>
> 5. 时间复杂度：平均O(N)，最坏O(N^2)。
>
>     > 1. 每次调用partition遍历的元素数目都是上一次遍历的1/2，因此时间复杂度是N+N/2+N/4+...+N/N=2N，因此时间复杂度是O(N)。
>     > 2. 若每次划分的位置在数组的后端，且K=1，那么最坏情况就是N^2。
>
> 6. 空间复杂度：O(1)。partition操作是原地进行的，不需额外空间。

> ```java
> class Solution {
>     public int[] getLeastNumbers(int[] arr,int k) {
>         if (k==0 || arr.length==0) return new int[]{};
>         if (arr.length<=k) return arr;
>         //原地不断划分数组
>         quickSearch(arr,k,0,arr.length-1);
>         //数组的前k个数此时就是最小的k个数，将其存入结果
>         int[] result=new int[k];
>         for (int i=0;i<k;i++) {
>             result[i]=arr[i];
>         }
>         return result;
>     }
> 
>     private void quickSearch(int[] arr,int k,int low,int high) {
>         //做一次partition操作，完毕后数组前m个数，就是最小的m个数
>         int m=partition(arr,low,high);
>         //正好找到最小的k个数
>         if (k==m) return;
>         if(m>k) quickSearch(arr,k,low,m-1);
>         else quickSearch(arr,k,m+1,high);
>     }
> 
>     //快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。
>     private int partition(int[] arr,int low,int high) {
>         int i=low;
>         int j=high+1;
>         int val=arr[low];
>         while(true){
>             while(++i<=high && arr[i]<val);
>             while(--j>=low && arr[j]>val);
>             if(i>=j) break;
>             int temp=arr[i];
>             arr[i]=arr[j];
>             arr[j]=temp;
>         }
>         arr[low]=arr[j];
>         arr[j]=val;
>         return j;
>     }
> }
> ```
>
> ```java
> //partition也可以按这样写
> private int quickSort(int[]arr,int low,int high) {
>     int baseNum=arr[low];//基准值
>     int i=low;//左指针
>     int j=high;//右指针
>     while(i<j){
>         while(i<j && arr[j]>=baseNum){//找到倒数第一个比基准小的值
>             j--;
>         }
>         while(i<j && arr[i]<=baseNum){//找到正数第一个比基准值大的值
>             i++;
>         }
>         int temp=arr[i];
>         arr[i]=arr[j];
>         arr[j]=temp;
>     }
>     //i和j相遇，将基准值赋给该位置
>     arr[low]=arr[i];
>     arr[i]=baseNum;
>     return i;
> }
> ```

### 数组中的第k个最大元素

#### Solution1. 小根堆

> ```java
> class Solution{
>     public int findKthLargest(int[] nums, int k) {
>         //创建小顶堆，堆中存储最大的k个元素，则堆顶即为第k大的数。
>         PriorityQueue<Integer> heap = new PriorityQueue<>();
>         for (int num : nums) {
>             if (heap.size()<k) heap.offer(num);
>                 //当前元素比堆顶元素大，且堆满，弹出堆顶。
>             else if (num>heap.peek()) {
>                 heap.poll();
>                 heap.offer(num);
>             }
>         }
>         return heap.peek();
>     }
> }
> ```

#### Solution2. 快排变形

> ```java
> class Solution {
>     public int findKthLargest(int[] nums, int k) {
>         //第k大的元素在升序数组中索引为n-k，在降序中索引为k-1，我们这里的快排实现的降序。
>         int index=quickSearch(nums,k-1,0,nums.length-1);
>         return nums[index];
>     }
> 
>     private int quickSearch(int[] arr,int k,int low,int high) {
>         //做一次partition操作，完毕后数组前m个数，就是最小的m个数
>         int index=quickSort(arr,low,high);
>         //正好找到最小的k个数
>         if (index==k) return index;
>         if(index>k) return quickSearch(arr,k,low,index-1);
>         else return quickSearch(arr,k,index+1,high);
>     }
> 
>     //快排切分，返回下标i，使得比nums[i]小的数都在i的右边，比nums[i]大的数都在i的左边。
>     private int quickSort(int[]arr,int low,int high) {
>         int baseNum=arr[low];//基准值
>         int i=low;//左指针
>         int j=high;//右指针
>         while(i<j){
>             while(i<j && arr[j]<=baseNum){//找到倒数第一个比基准大的值
>                 j--;
>             }
>             while(i<j && arr[i]>=baseNum){//找到正数第一个比基准值小的值
>                 i++;
>             }
>             int temp=arr[i];
>             arr[i]=arr[j];
>             arr[j]=temp;
>         }
>         //i和j相遇，将基准值赋给该位置
>         arr[low]=arr[i];
>         arr[i]=baseNum;
>         return i;
>     }
> }
> ```

## 查找

### 旋转数组查找给定值

> LeetCode-33
>
> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。
>
> > 例如：数组 [0,1,2,4,5,6,7] 旋转后可能变为 [4,5,6,7,0,1,2] 。

#### Solution1. 二分查找

> ```java
> class Solution {
>     public int search(int[] nums, int target) {
>         if(nums==null || nums.length==0) return -1;
>         int low=0;
>         int high=nums.length-1;
>         if(nums[0]<=nums[nums.length-1]) return binarySearch(nums,target,low,high);
>         while(nums[low]>nums[high]) high--;
>         if(target>=nums[low] && target<= nums[high]) return binarySearch(nums,target,low,high);
>         else if(target>=nums[high+1] && target<=nums[nums.length-1]) return binarySearch(nums,target,high+1,nums.length-1);
>         return -1;
>     }
> 
>     private int binarySearch(int[] nums,int target,int low,int high){
>         if(low>high) return -1;
>         int mid=low+((high-low)>>1);
>         if(nums[mid]==target) return mid;
>         if(nums[mid]<target) return binarySearch(nums,target,mid+1,high);
>         return binarySearch(nums,target,low,mid-1);
>     }
> }
> ```

#### Solution2. 二分查找

> 1. 将数组看成是两个有序的片段
> 2. 根据nums[low]与nums[mid]的关系判断mid是在左半段还是右半段
> 3. mid在左段说明mid及其左边的元素有序
> 4. mid在右端说明mid及其右边的元素有序

> ```java
> class Solution {
>     public int search(int[] nums, int target) {
>         int low=0;
>         int high=nums.length-1;
>         int mid=0;
>         while(low<=high){
>             mid=low+(high-low)/2;
>             if(nums[mid]==target){
>                 return mid;
>             }
>             if(nums[mid]>=nums[low]){
>                 if(target>=nums[low]&&target<=nums[mid]){
>                     high=mid;
>                 }
>                 else{
>                     low=mid+1;
>                 }
>             }
>             else{
>                 if(target<=nums[high]&&target>=nums[mid]){
>                     low=mid;
>                 }
>                 else {
>                     high=mid-1;
>                 }
>             }
>         }
>         return -1;
>     }
> }
> ```

#### Solution3. 范围排除

> 1. 将数组看成是两个有序的片段
> 2. 根据nums[0]与target的关系判断目标值是在左半段还是右半段
> 3. 目标值在左半段时，若mid在右半段，则将mid索引的值改成超大值，即排除mid及其右边这段范围。
> 4. 目标值在右半段时，若mid在左半段，则将mid索引的值改成超小值，即排除mid及其左边这段范围。
> 5. 逐渐移动low、high指针缩小范围。

> ```java
> class Solution {
>     public int search(int[] nums, int target) {
>         int low=0, high=nums.length-1;
>         while(low<=high) {
>             int mid=low+(high-low)/2;
>             if (nums[mid]==target){
>                 return mid;
>             }
>             if (target>=nums[0]){
>                 if (nums[mid]<nums[0]){
>                     nums[mid]=Integer.MAX_VALUE;
>                 }
>             } else{
>                 if(nums[mid]>=nums[0]){
>                     nums[mid]=Integer.MIN_VALUE;
>                 }
>             }
>             //缩小范围
>             if(nums[mid]<target){
>                 low=mid+1;
>             }else{
>                 high=mid-1;
>             }
>         }
>         return -1;
>     }
> }
> ```

### 数字在排序数组中出现的次数

> 剑指Offer-53I
>
> LeetCode-34
>
> 统计一个数字在排序数组中出现的次数。

#### 思路

> 1. 看见有序就用二分查找
> 2. 若数组中已有该元素，将其插入到最后一次出现的位置的右边。
> 3. 插入target和target-1，位置差即为该元素的个数。

#### Solution1. 二分查找右边界插入位置

> ```java
> class Solution {
>     public int search(int[] nums, int target) {
>         return binarySearch(nums,target)-binarySearch(nums,target-1);
>     }
>     private int binarySearch(int[] nums,int target){
>         int low=0;
>         int high=nums.length-1;
>         int mid=0;
>         while(low<=high){
>             mid=low+((high-low)>>>1);
>             if (target<nums[mid]){
>                 high=mid-1;
>             }
>             else {
>                 low=mid+1;
>             }
>         }
>         return low;
>     }
> }
> ```

### 旋转数组的最小数字

> 剑指Offer-11
>
> LeetCode-154
>
> 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，元素允许重复，输出旋转数组的最小元素。
>
> > 例如，数组[2,2,2,0,1]输出0。  

#### 思路

> 1. 有序用二分查找

#### Solution1. 二分查找

> ```java
> class Solution {
>     public int minArray(int[] numbers) {
>         int low=0;
>         int high=numbers.length-1;
>         int mid=0;
>         while(low<high){
>             mid=low+((high-low)>>>1);
>             //在mid右边
>             if(numbers[mid]>numbers[high]){
>                 low=mid+1;
>             }
>             //在mid及其左边
>             else if(numbers[mid]<numbers[high]){
>                 high=mid;
>             }
>             //在mid及其左边
>             else {
>                 high--;
>             }
>         }
>         return numbers[low];
>     }
> }
> ```

### 二分查找指定元素

> LeetCode-704
>
> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

#### Solution1.  循环

> ```java
> class Solution {
>        public int binarySearch(int[] arr,int target){
>            if(arr==null || arr.length==0) return -1;
>            int low=0;
>            int high=arr.length-1;
>            while(low<=high){
>                int mid=low+((high-low)>>1);    //不写成mid=(low+high)/2, 防止low+high过大溢出.
>                if(arr[mid]==target) return mid;
>                if(arr[mid]<target) low=mid+1;
>                else high=mid-1;
>            }
>            return -1;
>        }
>    }
>    ```

#### Solution2.  递归

```java
class Solution {
        public int binarySearch(int[] arr,int target){
        if(arr==null || arr.length==0) return -1;
        return searchHelper(arr,target,0,arr.length-1);
    }

    private int searchHelper(int[] arr,int target,int low,int high){
        if(low>high) return -1;
        int mid=low+((high-low)>>1);
        if(arr[mid]==target return mid;
        if(arr[mid]>target) return searchHelper(arr,target,low,mid-1);
        return searchHelper(arr,target,mid+1,high);
    }
}
```

### 二分查找第一个指定元素

> 在升序的整型数组nums中，查找第一个与指定值target 相等的元素的索引值，若没找到返回-1。

#### Solution1.  循环

> ```java
> class Solution {
>     public int binarySearch(int[] arr,int target){
>         if(arr==null || arr.length==0) return -1;
>         int low=0;
>         int high=arr.length-1;
>         while(low<=high){
>             int mid=low+((high-low)>>1);
>             if(mid==0 || arr[mid]==target){
>                 if(arr[mid-1]<target) return mid;
>                 high=mid-1;
>             }
>             else if(arr[mid]>target) high=mid-1;
>             else low=mid+1;
>         }
>         return -1;
>     }
> }
> ```

#### Solution2.  递归

> ```java
> class Solution {
>     public int binarySearch(int[] arr,int target){
>         if(arr==null || arr.length==0) return -1;
>         return searchHelper(arr,target,0,arr.length-1);
>     }
> 
>     private int searchHelper(int[] arr,int target,int low,int high){
>         if(low>high) return -1;
>         int mid=low+((high-low)>>1);
>         if(mid==0 || ( arr[mid]==target && arr[mid-1]<target)) return mid;
>         if(arr[mid]>target || (arr[mid]==target && arr[mid-1]==target)) return searchHelper(arr,target,low,mid-1);
>         return searchHelper(arr,target,mid+1,high);
>     }
> }
> ```

### 二分查找最后一个指定元素

> 在升序的整型数组nums中，查找最后一个与指定值target 相等的元素的索引值，若没找到返回-1。

#### Solution1.  循环

> ```java
> class Solution {
>     public int binarySearch(int[] arr,int target){
>         if(arr==null||arr.length==0) return -1;
>         int low=0;
>         int high=arr.length-1;
>         while(low<=high){
>             int mid=low+((high-low)>>1);
>             if(arr[mid]==target){
>                 if(mid==arr.length-1 || arr[mid+1]>target) return mid;
>                 low=mid+1;
>             }
>             else if(arr[mid]>target) high=mid-1;
>             else low=mid+1;
>         }
>         return -1;
>     }
> }
> ```

#### Solution2.  递归

> ```java
> class Solution {
>     public int binarySearch(int[] arr,int target){
>         if(arr==null || arr.length==0) return -1;
>         return searchHelper(arr,target,0,arr.length-1);
>     }
> 
>     private int searchHelper(int[] arr,int target,int low,int high){
>         if(low>high) return -1;
>         int mid=low+((high-low)>>1);
>         if(mid==arr.length-1 || arr[mid]==target && arr[mid+1]>target) return mid;
>         if(arr[mid]<target || (arr[mid]==target && arr[mid+1]<=target)) return searchHelper(arr,target,mid+1,high);
>         return searchHelper(arr,target,low,mid-1);
>     }
> }
> ```

### 二分查找第一个大于等于指定值的元素

> 在升序的整型数组nums中，查找第一个大于等于指定值target的元素的索引值，若没找到返回-1。

#### Solution1.  循环

> ```java
> class Solution {
>     public int binarySearch(int[] arr,int target){
>         if(arr==null||arr.length==0) return -1;
>         int low=0;
>         int high=arr.length-1;
>         while(low<=high){
>             int mid=low+((high-low)>>1);
>             if(mid==0 || arr[mid]>=target && arr[mid-1]<target) return mid;
>             if(arr[mid]<target) low=mid+1;
>             else high=mid-1;
>         }
>         return -1;
>     }
> }
> ```

#### Solution2.  递归

> ```java
> class Solution {
>     public int binarySearch(int[] arr,int target){
>         if(arr==null || arr.length==0) return -1;
>         return searchHelper(arr,target,0,arr.length-1);
>     }
> 
>     private int searchHelper(int[] arr,int target,int low,int high){
>         if(low>high) return -1;
>         int mid=low+((high-low)>>1);
>         if(mid==0 || arr[mid]>=target && arr[mid-1]<target) return mid;
>         if(arr[mid]<target) return searchHelper(arr,target,mid+1,high);
>         return searchHelper(arr,target,low,mid-1);
>     }
> }
> ```

### 二分查找最后一个小于等于指定值的元素

> 在升序的整型数组nums中，查找最后一个小于等于指定值target的元素的索引值，若没找到返回-1。

#### Solution1.  循环

> ```java
> class Solution {
>     public int binarySearch(int[] arr,int target){
>         if(arr==null||arr.length==0) return -1;
>         int low=0;
>         int high=arr.length-1;
>         while(low<=high){
>             int mid=low+((high-low)>>1);
>             if(mid==arr.length-1 || arr[mid]<=target && arr[mid+1]>target) return mid;
>             if(arr[mid]>target) high=mid-1;
>             else low=mid+1;
>         }
>         return -1;
>     }
> }
> ```

#### Solution2.  递归

> ```java
> class Solution {
> 	public int binarySearch(int[] arr,int target){
>         if(arr==null || arr.length==0) return -1;
>         return searchHelper(arr,target,0,arr.length-1);
>     }
> 
>     private int searchHelper(int[] arr,int target,int low,int high){
>         if(low>high) return -1;
>         int mid=low+((high-low)>>1);
>         if(mid==arr.length-1 || arr[mid]<=target && arr[mid+1]>target) return mid;
>         if(arr[mid]>target) return searchHelper(arr,target,low,mid-1);
>         return searchHelper(arr,target,mid+1,high);
>     }
> }
> ```

### 0～n-1中缺失的数字

> 剑指Offer-53II
>
> 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

#### 思路

> 1. 二分查找找到第一个值和index不相等的元素

#### Solution1. 二分查找

> ```java
> class Solution {
>     public int missingNumber(int[] nums) {
>         int low=0;
>         int high=nums.length-1;
>         int mid=0;
>         while(low<=high){
>             mid=low+((high-low)>>>1);
>             if (mid==nums[mid]) {
>                 low=mid+1;
>             }
>             else{
>                 high=mid-1;
>             }
>         }
>         return low;
>     }
> }
> ```

## 数组

### 构建乘积数组

> 剑指Offer-66
>
> 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]\*A[1]\*...\*A[i-1]\*A[i+1]\*...\*A[n-1]。不能使用除法。规定B[0] = A[1] \* A[2] \* ... \* A[n-1]，B[n-1] = A[0] \* A[1] \* ... \* A[n-2];

#### 思路

> 1. B[i]=A[0]到A[n-1]中除了A[i]外的乘积之和

#### Solution1.

> ```java
> class Solution {
>     public int[] multiply(int[] A) {
>         int[] B = new int[A.length];
>         for (int i=0;i<B.length;i++){
>             B[i]=1;
>             for (int j=0;j<A.length;j++){
>                 if (i==j){
>                     continue;
>                 }
>                 B[i]*=A[j];
>             }
>         }
>         return B;
>     }
> }
> ```

#### Solution2. 

> 1. Bn和Bn-1只差两个乘数不同，则可利用相邻元素乘好的一部分积。
>
>     ![image-20200416122725194](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200416122725194.png)

> ```java
> class Solution {
>     public int[] multiply(int[] A) {
>         int[] B = new int[A.length];
>         if (A.length!=0){
>             B[0]=1;
>             for (int i=1;i<B.length;i++){
>                 B[i]=B[i-1]*A[i-1];
>             }
>             int temp=1;
>             for (int i=B.length-2;i>=0;i--){
>                 temp*=A[i+1];
>                 B[i]*=temp;
>             }
>         }
>         return B;
>     }
> }
> ```

### 顺时针打印矩阵

> 剑指Offer-29
>
> LeetCode-54
>
> 给定一个包含 *m* x *n* 个元素的矩阵（*m* 行, *n* 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

#### Solution1. 循环

> 1. layers是循环遍历的圈数，由行和列的较小值决定，-1是为了考虑较小值为奇数的情况，除以2是因为每次循环都会因顶部从左到右和底部从右到左而用掉2行，所以只取一半，+1是为了补偿之前-1造成的奇数情况下的0.5层以及偶数情况下少1层。
>
> 2. 从左上到右上
>
>     > 1. 行坐标不变，每轮完成会用掉前i行，所以此次遍历行坐标为i。
>     > 2. 列坐标变，每轮的左下至左上会用掉1个当前行前面的元素，右上至右下会用掉1个当前行右边的元素，所以此次遍历列坐标从i开始，边界为col-i。
>
> 3. 从右上到右下
>
>     > 1. 行坐标变，每轮完成会用掉前i行，这一轮的从左上到右上会多用掉当前列上面的1个元素，所以此次遍历行坐标从i+1开始，每轮的右下至左下会用掉1个当前列下面的元素，所以边界为row-i。
>     > 2. 列坐标不变，每轮完成会用掉后i列，所以列坐标为col-i-1。
>
> 4. 从右下至左下
>
>     > 1. 行坐标不变，为row-i-1，不能撞上该轮左上至右上遍历完成的那一行，所以边界之一为row-i-1!=i。
>     > 2. 列坐标变，这一轮的右上到右下会用掉一个当前行后面的元素，所以列坐标从col-i-2开始。不能撞上前几轮已完成的前几列，所以边界之一为>=i。
>
> 5. 从左下至左上
>
>     > 1. 行坐标变，这一轮的右下到左下会用掉一个当前列后面的元素，所以行坐标从col-i-2开始。不能撞上前几轮已完成的前几行，所以边界之一为>=i。
>     > 2. 列坐标不变，每轮完成前i列，该轮列坐标从i开始，边界为不撞上该轮右上至右下遍历完成的那列，所以边界之一为col-i-1!=i。

> ```java
> class Solution {
>     public int[] spiralOrder(int[][] matrix) {
>         int row=matrix.length;
>         if(row==0) return new int[]{};
>         int col=matrix[0].length;
>         int[] result=new int[row*col];
>         int index=0;
>         /*
>          * layers是循环遍历的圈数，由行和列的较小值决定，-1是为了考虑较小值为奇数的情况，
>          * 除以2是因为每次循环都会因顶部从左到右和底部从右到左而用掉2行，所以只取一半，
>          * +1是为了补偿之前-1造成的奇数情况下的0.5层以及偶数情况下少1层
>          */
>         int layers = (Math.min(row,col)-1)/2+1;
>         for(int i=0;i<layers;i++){
>             /*
>              * 从左上到右上
>              * 行坐标不变，每轮完成会用掉前i行，所以此次遍历行坐标为i。
>              * 列坐标变，每轮的左下至左上会用掉1个当前行前面的元素，右上至右下会用掉1个当前行右边的元素，所以此次遍历列坐标从i开始，边界为col-i。
>              */
>             for(int k=i;k<col-i;k++) result[index++]=matrix[i][k];
>             /*
>              * 从右上到右下
>              * 行坐标变，每轮完成会用掉前i行，这一轮的从左上到右上会多用掉当前列上面的1个元素，所以此次遍历行坐标从i+1开始，每轮的右下至左下会用掉1个当前列下面的元素，所以边界为row-i。
>              * 列坐标不变，每轮完成会用掉后i列，所以列坐标为col-i-1。
>              */
>             for(int j=i+1;j<row-i;j++) result[index++]=matrix[j][col-i-1];
>             /*
>              * 从右下至左下
>              * 行坐标不变，为row-i-1，不能撞上该轮左上至右上遍历完成的那一行，所以边界之一为row-i-1!=i。
>              * 列坐标变，这一轮的右上到右下会用掉一个当前行后面的元素，所以列坐标从col-i-2开始。不能撞上前几轮已完成的前几列，所以边界之一为>=i。
>              */
>             for(int k=col-i-2;(k>=i)&&(row-i-1!=i);k--) result[index++]=matrix[row-i-1][k];//右至左
>             /*
>              * 从左下至左上
>              * 行坐标变，这一轮的右下到左下会用掉一个当前列后面的元素，所以行坐标从col-i-2开始。不能撞上前几轮已完成的前几行，所以边界之一为>=i。
>              * 列坐标不变，每轮完成前i列，该轮列坐标从i开始，边界为不撞上该轮右上至右下遍历完成的那列，所以边界之一为col-i-1!=i。
>              */
>             for(int j=row-i-2;(j>i)&&(col-i-1!=i);j--) result[index++]=matrix[j][i];
>         }
>         return result;
>     }
> }
> ```

### 二维数组中的查找

>剑指Offer-04
>
>LeetCode-240
>
>在一个n*m的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

#### 思路

> 1. 充分利用已知信息，若从左上角或右下角开始遍历，每次都有两个方向可以选。我们从左下角或右上角开始遍历来优化，每种情况只有一条路可走，窄化选择。
>
> 2. 假设从左下角开始遍历。
>
>     >1. 目标值比当前元素小，该元素右方的所有元素均比当前还大，整行排除，行坐标上移。
>     >2. 目标值比当前元素大，该元素上方的所有元素均比当前还小，整列排除，列坐标右移。
>
> 3. 遇到边界则说明没找到。

#### Solution1. 

> ```java
> class Solution {
>     public boolean findNumberIn2DArray(int[][] matrix, int target) {
>         //从左下角开始遍历
>         int i=matrix.length-1; //行坐标
>         int j=0; //列坐标
>         //界内遍历
>         while(i>=0 && j<matrix[0].length){
>             if(matrix[i][j]==target) return true;
>             //若当前元素比目标值小，该元素上方的所有元素均比当前还小，整列排除，列坐标右移。
>             if (matrix[i][j]<target) j++;
>             //若当前元素比目标值大，该元素右方的所有元素均比当前还大，整行排除，行坐标上移。
>             else i--;
>         }
>         return false;
>     }
> }
> ```

### 数组中重复的数字

> 剑指Offer-03
>
> 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 
>
> > 例如：如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。

#### Solution1. 辅助标记数组

> ```java
> class Solution {
>     public int findRepeatNumber(int[] nums) {
>         boolean[] flag = new boolean[nums.length];
>         for (int i=0;i<nums.length;i++){
>             if (flag[nums[i]]==true){
>                 return nums[i];
>             }
>             flag[nums[i]]=true;
>         }
>         return -1;
>     }
> }
> ```

#### Solution2. 辅助数组统计

> ```java
> class Solution {
>     public int findRepeatNumber(int[] nums) {
>         int[] count = new int[nums.length];
>         for (int i=0;i<nums.length;i++){
> 			count[nums[i]]++;
> 		}
> 		for(int i=0;i<nums.length;i++){
> 			if (count[i]>1){
> 				return i;
>             }
>         }
> 		return -1;
>     }
> }
> ```

#### Solution3. 原数组上做标记

> 1. 对数组长度取余，即为该数字的值，将对应坐标的值加上一个值，使该位置的值大于规定的范围，若遇到重复的数字时，查到对应的位置值不在范围内，则判断出为重复数字。

> ```java 
> class Solution {
>     public int findRepeatNumber(int[] nums) {
>         for (int i = 0; i < nums.length; i++) {
>             int index = nums[i] % nums.length;
>             if (nums[index] >= nums.length) {
>                 return index;
>             }
>             nums[index] += nums.length;
>         }
>         return -1;
>     }
> }
> ```

### 数组中只出现1次的两个数字

> 剑指Offer-56I
>
> 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

#### Solution1. HashSet

> ```java
> class Solution {
>     public int[] singleNumber(int[] nums) {
>         HashSet set = new HashSet();
>         for(int i=0;i<nums.length;i++){
>             boolean flag=set.add(nums[i]);
>             if(flag==false) set.remove(nums[i]);
>         }
>         int[] result = new int[set.size()];
>         Iterator iterator = set.iterator();
>         for(int i=0;i<set.size();i++){
>             result[i] = (int)iterator.next();
>         }
>         return result;
>     }
> }
> ```

#### Solution2. 分组位运算

> ```java
> class Solution {
>     public int[] singleNumbers(int[] nums) {
>         int n=0;
>         for(int i=0;i<nums.length;i++){
>             n^=nums[i];
>         }
>         int index=0;
>         while(n%2!=1){
>             n=n>>>1;
>             index++;    //index为两个只出现一次的不等数的二进制数最低位不等的索引位置
>         }
>         List odd = new ArrayList();
>         List even = new ArrayList();
>         for(int i=0;i<nums.length;i++){
>             int m=nums[i]>>>index;
>             if(m%2==1) odd.add(nums[i]);
>             else even.add(nums[i]);
>         }
>         int a=operate(odd);
>         int b=operate(even);
>         return new int[]{a,b};
>     }
> 
>     private int operate(List list){
>         int num=0;
>         for(int i=0;i<list.size();i++){
>             num^=(int)list.get(i);
>         }
>         return num;
>     }
> }
> ```

#### Solution3. 位运算

> 1. 异或可消除出现两次的数字，剩下的结果是两个单独的数字的异或结果，即二者的差异。
>
> 2. 找到最右边的1，这个差异1只可能来源于二者之一。这步有两种方法：
>
>     ```
>     //&运算：x&(-x)的作用是保留位中最后一个1，其余的1设为0。
>     int last = different & (-different);
>     
>     //移位运算
>     int last=1;
>     while((different&last)==0){
>     	last=last<<1;
>     }
>     ```
>
> 3. 再次异或，其余有该位1的相同两数被抵消，单独的两个数字中，只有一者该位有1，与last进行&运算，结果不为0则说明这个1来自于该数，与0进行^运算得到该数。
>
>     ```
>     //后面的遍历异或，也可以这样写：
>     int result[] = new int[2];
>     for (int i=0;i<nums.length;i++){//两个单独的数与差异位1进行&操作，结果一个是0另一个是1。
>     	if ((nums[i] & last) == 0) {
>     		result[0] ^= nums[i];
>     	} else {
>     		result[1] ^= nums[i];
>     	}
>     }
>     return result;
>     ```
>
> 4. 已知其一，则该数与different进行^运算，即得到另一个数。

> ```java
> class Solution {
>     public int[] singleNumber(int[] nums) {
>         int different = 0;
>         for (int num : nums){
>             different ^= num;
>         }
>         int last = different & (-different);
>         int a = 0;
>         for (int num : nums){
>             if ((num & last) != 0){
>                 a ^= num;
>             }
>         }
>         return new int[]{a, different^a};
>     }
> }
> ```

### 扑克牌的顺子

> 剑指Offer-61
>
> 从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

#### 思路

> 1. 除0外不能有重复的数字，最大减最小值需<5

#### Solution1. 

> ```java
> class Solution {
>     public boolean isContinuous(int [] numbers) {
>         if (numbers.length==0){
>             return false;
>         }
>         boolean[] isExist = new boolean[13];
>         int count0 =0;
>         int max=0;
>         int min=isExist.length;
>         for (int i=0;i<numbers.length;i++){
>             if (numbers[i]!=0){
>                 if (isExist[numbers[i]-1]) {
>                     return false;
>                 }
>                 isExist[numbers[i]-1]=true;
>                 max=numbers[i]>max?numbers[i]:max;
>                 min=numbers[i]<min?numbers[i]:min;
>             }
>             else {
>                 count0++;
>             }
>         }
>         if (count0==5){
>             return true;
>         }
>         return max-min<5?true:false;
>     }
> }
> ```

### 和为s的连续正数序列

> 剑指Offer-57II
>
> 输入一个正整数target，输出所有和为 target 的连续正整数序列（至少含有两个数），序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

#### Solution1. 

> 1. ArrayList<int[]>转二维数组：`result.toArray(new int[0][]);`

> ```java
> class Solution {
>     public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
>         int start=1;
>         int end=2;
>         int calculate=0;
>         ArrayList<ArrayList<Integer>> result=new ArrayList<>();
>         while (start<end){
>             calculate=(start+end)*(end-start+1)/2;
>             if (calculate==sum){
>                 ArrayList<Integer> list = new ArrayList<>();
>                 for(int i=start;i<=end;i++){
>                     list.add(i);
>                 }
>                 result.add(list);
>                 start++;
>             }
>             else if (calculate<sum){
>                 end++;
>             }
>             else start++;
>         }
>         return result;
>     }
> }
> ```

### 数组中出现次数超过一半的数字

> 剑指Offer-39
>
> LeetCode-169
>
> 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。如果不存在则输出0。

#### Solution1. 排序

> 1. 将数组从小到大排序，则数组长度÷2，向下取整，若存在该数字，则一定会出现在这个位置。
> 2. 再次遍历统计该数字出现次数，判断是否大于一半。
> 3. 时间复杂度：排序需要O(N·logN)，遍历需要O(N)。

> ```java
> class Solution {
>     public int majorityElement(int[] nums) {
>         Arrays.sort(nums);
>         int num=nums[nums.length/2];
>         int count=0;
>         for (int n : nums) {
>             if (n==num){
>                 count++;
>             }
>         }
>         return count>nums.length/2?num:0;
>     }
> }
> ```

#### Solution2. 摩尔标记

> 1. 采用阵地攻守的思想
> 2. 第一个数字作为第一个士兵，守阵地，vote=1。
> 3. 遇到相同元素，vote++。
> 4. 遇到不相同元素，即为敌人，同归于尽，vote--。
> 5. 当遇到vote为0的情况，又以新的值作为守阵地的士兵，继续下去，到最后还留在阵地上的士兵，有可能是主元素。
> 6. 再加一次循环，记录这个士兵的个数看是否大于数组一般即可。

> ```java
> class Solution {
>     public int majorityElement(int[] nums) {
>         int num=0;
>         int vote=0;
>         int count=0;
>         for(int n : nums){
>             if(vote==0){
>                 num=n;
>             }
>             vote+=(n==num)?1:-1;
>         }
>         for(int a : nums){
>             if(a==num){
>                 count++;
>             }
>         }
>         return count>nums.length/2?num:0;
>     }
> }
> ```

#### Solution3. HashMap

> 1. 边遍历，边统计，边判断。

> ```java
> class Solution {
>     public int majorityElement(int[] nums) {
>         if (nums.length==1){
>             return nums[0];
>         }
>         Map<Integer,Integer> map = new HashMap();
>         for (int num : nums) {
>             if (map.containsKey(num)){
>                 int count = map.get(num)+1;
>                 if (count>nums.length/2){
>                     return num;
>                 }
>                 map.put(num,count);
>             }
>             else {
>                 map.put(num,1);
>             }
>         }
>         return 0;
>     }
> }
> ```

### 调整数组顺序使奇数位于偶数前面

> 剑指Offer-21
>
> 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

#### Solution1. 双指针

> ```java
> class Solution {
>     public int[] exchange(int[] nums) {
>         int left=0;
>         int right=nums.length-1;
>         int temp;
>         while (left<right){
>             //从左开始找到偶数
>             while ((nums[left]&1)==1 && left<right){
>                 left++;
>             }
>             //从右开始找到奇数
>             while ((nums[right]&1)==0 && left<right){
>                 right--;
>             }
>             //交换
>             temp=nums[left];
>             nums[left]=nums[right];
>             nums[right]=temp;
>         }
>         return nums;
>     }
> }
> ```

#### 拓展. 相对位置不变

> 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分，且保持奇数与奇数、偶数与偶数之间的相对位置不变。

##### Solution1. 双指针

> ```java
> class Solution {
>     public int[] exchange(int[] nums) {
>         int odd;
>         int even=0;
>         int temp;
>         while (even<nums.length){
>             //从左开始找到偶数
>             while (even<nums.length && (nums[even]&1)==1){
>                 even++;
>             }
>             //从左边的偶数之后找到奇数
>             odd=even+1;
>             while (odd<nums.length && (nums[odd]&1)==0){
>                 odd++;
>             }
>             if (odd>=nums.length){
>                 break;
>             }
>             //将奇数到偶数之间的偶数们全往右移，奇数换到第一个偶数位置。
>             temp=nums[odd];
>             for(int i=odd-1;i>=even;i--){
>                 nums[i+1]=nums[i];
>             }
>             nums[even]=temp;
>         }
>         return nums;
>     }
> }
> ```

### 和为s的两个数

> 剑指Offer-57
>
> 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

#### 思路

> 1. 充分利用已知信息，排序数组，我们使用双指针优化。
> 2. 双指针，分别从前后两端开始遍历。
> 3. 若和大于目标值，则后指针往前移，小于则前指针后移，等于则返回。
> 4. 边界条件为两指针相遇，表示已遍历完，没有结果。

#### Solution1. 双指针

> 1. 时间复杂度：O(N)。需遍历一遍。
> 2. 空间复杂度：O(1)。

> ```java
> class Solution {
>     public int[] twoSum(int[] nums, int target) {
>         int low=0;
>         int high=nums.length-1;
>         while (low<high){
>             int sum=nums[low]+nums[high];
>             if (sum==target){
>                 return new int[]{nums[low],nums[high]};
>             }
>             if (sum > target){
>                 high--;
>             }
>             else {
>                 low++;
>             }
>         }
>         return new int[]{};
>     }
> }
> ```

#### 拓展

> 输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，要求输出两个数的乘积最小的，且输出两个数时，小的先输出。

##### 思路

> 1. 已知是有序数组。
> 2. 双指针分别从前后两端遍历时，第一次和为目标值的两个元素，乘积一定是最大的。
> 3. 左指针即是两数较小者，右指针即时两数较大者。
> 4. 所以代码和拓展前的题目没有区别。

### 杨辉三角

> LeetCode-118
>
> 给定一个非负整数numRows，生成杨辉三角的前numRows行。
>
> > 例如：
> >
> > 输入: 5
> >
> > 输出：
> >
> > ```
> > [
> >      [1],
> >     [1,1],
> >    [1,2,1],
> >   [1,3,3,1],
> >  [1,4,6,4,1]
> > ]
> > ```

#### Solution1. 

> ```java
> class Solution {
>     public List<List<Integer>> generate(int numRows){
>         List<List<Integer>> result=new ArrayList();
>         List<Integer> arr=null;
>         for(int i=0;i<numRows;i++){
>             arr=new ArrayList();
>             for(int j=0;j<=i;j++){
>                 if(j==0||j==i){
>                     arr.add(1);
>                 }
>                 else{
>                     arr.add(result.get(i-1).get(j-1)+result.get(i-1).get(j));
>                 }
>             }
>             result.add(arr);
>         }
>         return result;
>     }
> }
> ```

## 链表

### 链表中环的入口结点

> 剑指Offer-23
>
> 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。

#### Solution1. 

> ```java
> class Solution {
>     public ListNode EntryNodeOfLoop(ListNode pHead){
>         ListNode p=pHead;
>         ArrayList c = new ArrayList();
>         while(!c.contains(p)){
>             c.add(p);
>             if(p.next==null){
>                 return null;
>             }
>             p=p.next;
>         }
>         return p;
>     }
> }
> ```

### 链表检测环

> LeetCode-141
>
> 给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

#### 思路

> 1. 快慢指针，相遇则有环。

#### Solution1. 双指针

> ```java
> class Solution {
>     public boolean hasCycle(ListNode head) {
>         if(head==null||head.next==null){
>             return false;
>         }
>         ListNode slow=head;
>         ListNode fast=head.next;
>         while(slow!=fast){    //迟早相遇则有环
>             if(fast==null||fast.next==null){    //快指针一次走两步，需判断2个条件。
>                 return false;
>             }
>             slow=slow.next;    //慢指针一次走一步
>             fast=fast.next.next;    //快指针一次走两步
>         }
>         return true;
>     }
> }
> ```

### 链表中倒数第4个节点

>剑指Offer-22
>
>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。要注意边界条件，若k大于元素个数，返回null。
>
>> 例如：一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。

#### 思路

> 1. 链表有n个元素，倒数第k个元素，即指针走n-k步即可找到该元素。
> 2. 但首先要知道n，这样要遍历两遍，所以我们用双指针来优化。
> 3. 快指针k先走步，慢指针再开始走，两者之间间隔k步。
> 4. 快指针再走n-k步即到达末尾，此时慢指针刚好走n-k步到达目标位置。
> 5. 若k大于元素个数，返回null。

#### Solution1. 双指针

> ```java
> class Solution {
>     public ListNode getKthFromEnd(ListNode head, int k) {
>         ListNode fast=head;
>         ListNode slow=head;
>         while (k>0){
>             if (fast==null){
>                 return null;
>             }
>             fast=fast.next;
>             k--;
>         }
>         while (fast!=null){
>             fast=fast.next;
>             slow=slow.next;
>         }
>         return slow;
>     }
> }
> ```
>
> ```java
> class Solution {
>     public ListNode getKthFromEnd(ListNode head, int k) {
>         ListNode fast=head;
>         ListNode slow=head;
>         int n=0;
>         while (fast!=null){
>             fast=fast.next;
>             if(n>=k){
>                 slow=slow.next;
>             }
>             n++;
>         }
>         return n>=k?slow:null;
>     }
> }
> ```

### 圆圈中最后剩下的数字

> 剑指Offer-62
>
> 圆圈中最后剩下的数字，0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。即约瑟夫环。

#### Solution1. 入队出队

> 1. 将元素存在队列中，报数<m的依次放到队尾，报数为m的直接出列，m重置继续报数。

> ```java
> class Solution {
>     public int lastRemaining(int n, int m) {
>         List<Integer> list=new ArrayList<>();
>         for(int i=0;i<n;i++)
>             list.add(i);
>         while(list.size()>1){
>             for(int j=0;j<m;j++){
>                 if(j!=m-1)
>                     list.add(list.get(0));
>                 list.remove(0);
>             }
>         }
>         return list.get(0);
>     }
> }
> ```

#### Solution2. 指定坐标删除

> 1. 将元素存在链表中，第一次删除的元素下标为(m-1)%n，之后每一次删除的元素下标为(前一个删除的元素的坐标+m-1)%当前列表长度。

> ```java
> class Solution {
>     public int lastRemaining(int n, int m) {
>         if(n<1||m<1)
>             return -1;
>         List<Integer> list=new ArrayList<>();
>         for(int i=0;i<n;i++){
>             list.add(i);
>         }
>         int index=(m-1)%n;
>         while(list.size()>1) {
>             list.remove(index);
>             index=(index+m-1)%list.size();
>         }
>         return list.get(0);
>     }
> }
> ```

#### Solution3. 数学公式法

> 1. 用这一轮的坐标求它在上一轮的坐标，如此不停迭代求得在原始列表中的坐标。

> ```java
> class Solution {
>     public int lastRemaining(int n, int m) {
>         if(n<1||m<1)
>             return -1;
>         if(n==1){
>             return 0;
>         }
>         return ((lastRemaining(n-1,m))+m)%n;
>     }
> }
> ```

### 两个链表的第一个公共结点	

> 剑指Offer-52
>
> LeetCode-160
>
> 输入两个链表，找出它们的第一个公共节点。
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

#### 思路

> 1. 设公共链表的长度为n，则链表A的长度为a+n，链表B的长度为b+n。
> 2. A、B两指针走过的路程数始终相等。
> 3. 利用上有公共链表这个已知条件，最能联想到的情况为(a+n)+b=(b+n)+a。
> 4. 所以遍历完A则从B链表头开始遍历，遍历完B则从A链表头继续，两者都历经该轮后，会在第一个公共点相遇。

#### Solution1. 

> ```java
> class Solution {
>     public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
>         ListNode p1=headA;
>         ListNode p2=headB;
>         while(p1!=p2){
>             p1=(p1==null)?headB:p1.next;
>             p2=(p2==null)?headA:p2.next;
>         }
>         return p1;
>     }
> }
> ```

### 反转链表

> 剑指Offer-24
>
> LeetCode-206
>
> 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

#### Solution1. 

> ```java
> class Solution {
>     public ListNode reverseList(ListNode head) {
>         ListNode pre=null;
>         ListNode next=null;
>         while (head!=null){
>             next=head.next;
>             head.next=pre;
>             pre=head;
>             head=next;
>         }
>         return pre;
>     }
> }
> ```

### 从尾到头打印链表

> 剑指Offer-06
>
> 输入一个链表，按链表从尾到头的顺序返回一个ArrayList或数组。

#### 思路

> 1. 若要求返回的是数组，首先我们得需要知道元素个数才能生成数组，这就免不了得先遍历一次链表。可以使用栈存放结点值，也可以使用List存放结点值。然后生成数组，转移元素。

#### Solution1. 辅助栈

> ```java
> class Solution {
>     public int[] reversePrint(ListNode head) {
>         Stack<Integer> stack = new Stack<>();
>         while(head!=null){
>             stack.push(head.val);
>             head=head.next;
>         }
>         int len=stack.size();
>         int[] result=new int[len];
>         for(int i=0;i<len;i++){
>             result[i]=stack.pop();
>         }
>         return result;
>     }
> }
> ```

#### Solution2.  递归

> ```java
> class Solution {
>     ArrayList<Integer> result;
>     public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
>         result=new ArrayList<>();
>         recur(listNode);
>         return result;
>     }
> 
>     private void recur(ListNode head){
>         if (head==null){
>             return;
>         }
>         recur(head.next);
>         result.add(head.val);
>     }
> }
> ```

### 复制带随机指针的链表

> 剑指Offer-35
>
> LeetCode-138
>
> 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

#### Solution1. HashMap

> 1. 以空间换时间
> 2. 时间复杂度：O(N)
> 3. 空间复杂度：O(N)

> ```java
> class Solution{
>     public Node copyRandomList(Node head) {
>         if (head==null) return null;
>         HashMap<Node,Node> map=new HashMap<>();
>         Node p=head;
>         while(p!=null){
>             map.put(p,new Node(p.val));
>             p=p.next;
>         }
>         p=head;
>         while(p!=null){
>             map.get(p).next=map.get(p.next);
>             map.get(p).random=map.get(p.random);
>             p=p.next;
>         }
>         return map.get(head);
>     }
> }
> ```

#### Solution2. HashMap

> 1. 改变原来的链表，则可以不需要额外的空间。
> 2. 遍历原来的链表并拷贝每一个节点，将拷贝节点放在原来节点的旁边，使旧节点和新节点交错。
> 3. 迭代这个新旧节点交错的链表，用旧节点的random指针去更新对应新节点的random指针。
> 4. 将next指针正确赋值，以便将新的节点正确链接，同时将旧节点重新正确链接。
> 5. 时间复杂度：O(N)
> 6. 空间复杂度：O(1)

> ```java
> public class Solution {
>     public Node copyRandomList(Node head){
>         if(head==null) return null;
>         Node p=head;
>         while(p!=null){
>             Node node=new Node(p.val);
>             node.next=p.next;
>             p.next=node;
>             p=node.next;
>         }
>         p=head;
>         while (p!=null) {
>             if(p.random!=null) p.next.random=p.random.next;//为什么是random.next
>             p=p.next.next;
>         }
>         Node oldList = head;
>         Node newList = head.next;
>         Node newHead = head.next;
>         while (oldList != null) {
>             oldList.next = oldList.next.next;
>             if(newList.next!=null) newList.next=newList.next.next;
>             oldList = oldList.next;
>             newList = newList.next;
>         }
>         return newHead;
>     }
> }
> ```

### LRU

> LeetCode-146
>
> 设计和实现一个时间复杂度为O(1)的LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。
>
> > 1. 获取数据get(key)：如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。
> > 2. 写入数据put(key, value)：如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

#### 思路

> 1. 现成的LinkedHashMap可以解决，但我们用HashMap+自己实现的双向链表来实现。

#### Solution1. HashMap+双向链表

> ```java
> public class LRUCache {
>     class DqueueNode {
>         int key;
>         int value;
>         DqueueNode prev;
>         DqueueNode next;
> 
>         public DqueueNode() {
>         }
> 
>         public DqueueNode(int k, int v) {
>             key = k;
>             value = v;
>         }
>     }
> 
>     private Map<Integer, LRUCache.DqueueNode> cache;
>     private DqueueNode head;
>     private DqueueNode tail;
>     private int capacity;
>     private int size;
> 
>     public LRUCache(int capacity) {
>         this.capacity = capacity;
>         this.size = 0;
>         cache = new HashMap<Integer, LRUCache.DqueueNode>();
>         head = new DqueueNode();
>         tail = new DqueueNode();
>         head.next = tail;
>         tail.prev = head;
>     }
> 
>     public void put(int key, int value) {
>         DqueueNode node = cache.get(key);
>         //元素已存在，更新值
>         if (node!=null) {
>             node.value = value;
>             moveToTail(node);
>         }
>         //新元素，判断容量，添加到map和队尾，更新size
>         else {
>             //容量已满，需淘汰位于队首的最久未使用的缓存
>             if (size>=capacity) {
>                 cache.remove(head.next.key);
>                 removeHead();
>             }
>             //新元素添加到队尾
>             node=new DqueueNode(key,value);
>             addToTail(node);
>             cache.put(key,node);
>             size++;
>         }
>     }
> 
>     public int get(int key){
>         DqueueNode node = cache.get(key);
>         //元素已存在，新使用，移到队尾
>         if (node!=null) {
>             moveToTail(node);
>             return node.value;
>         }
>         return -1;
>     }
> 
>     private void addToTail(DqueueNode node) {
>         node.prev=tail.prev;
>         node.next=tail;
>         tail.prev.next=node;
>         tail.prev=node;
>     }
> 
>     private void moveToTail(DqueueNode node) {
>         node.prev.next=node.next;
>         node.next.prev=node.prev;
>         addToTail(node);
>     }
> 
>     private  void removeHead() {
>         head.next.next.prev=head;
>         head.next=head.next.next;
>     }
> }
> ```

### LFU

#### Solution1. 小根堆

> 1. 给每个元素加个时间戳，每次将访问频数最少里时间戳最早的放到小根堆堆顶，有现成的PriorityQueue默认小根堆。
> 2. 时间复杂度：O(1)。

#### Solution2. 嵌套双向链表

> 1. 给每一个频数建一条双向链表，链表里按添加顺序排列。
> 2. 将频数链表按频数大小以双向链表的形式串联。
> 3. 时间复杂度：O(logN)。

## 栈/队列

### 栈的压入、弹出序列

> 剑指Offer-31
>
> LeetCode-946
>
> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。
>
> >  例如：序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

#### Solution1. 辅助栈模拟

> ```java
> class Solution {
>     public boolean validateStackSequences(int[] pushed, int[] popped) {
>         Stack<Integer> stack = new Stack<>();
>         int index=0;
>         for (int num : pushed) {
>             stack.push(num);
>             while(!stack.isEmpty() && stack.peek()==popped[index]){
>                 stack.pop();
>                 index++;
>             }
>         }
>         return stack.isEmpty();
>     }
> }
> ```

### 用两个栈实现队列

> 剑指Offer-09
>
> 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

#### Solution1. 

> ```java
> class Solution {
>     Stack<Integer> stack1 = new Stack<Integer>();
>     Stack<Integer> stack2 = new Stack<Integer>();
>  
>     public void push(int node) {
>         stack1.push(node);
>     }
>  
>     public int pop() {
>         if (stack2.isEmpty()){
>             while (!stack1.isEmpty()){
>                 stack2.push(stack1.pop());
>             }
>         }
>         return stack2.pop();
>     }
> }
> ```

### 队列中的最大值

> 剑指Offer-59II
>
> 请定义一个队列并实现函数max_value()得到队列里的最大值，要求函数max_value、push_back 和 pop_front     的均摊时间复杂度都是O(1)。若队列为空，pop_front 和 max_value 需要返回 -1。

#### Solution1. 双端队列

> ```java
> class MaxQueue {
>     LinkedList<Integer> maxQueue;
>     LinkedList<Integer> result;
> 
>     public MaxQueue() {
>         maxQueue=new LinkedList<Integer>();
>         result=new LinkedList<Integer>();
>     }
> 
>     public int max_value() {
>         return maxQueue.isEmpty()?-1:maxQueue.peekFirst();
>     }
> 
>     public void push_back(int value) {
>         result.add(value);
>         while ((!maxQueue.isEmpty())&&value>maxQueue.peekLast()){
>             maxQueue.removeLast();
>         }
>         maxQueue.add(value);
>     }
> 
>     public int pop_front() {
>         if (result.isEmpty()){
>             return -1;
>         }
>         if (result.peekFirst().intValue()==maxQueue.peekFirst().intValue()){
>             maxQueue.removeFirst();
>         }
>         return result.removeFirst();
>     }
> }
> ```

### 包含min函数的栈

> 剑指Offer-30
>
> LeetCode-155
>
> 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

#### Solution1. 

> ```java
> class MinStack {
>     Stack<Integer> result;
>     Stack<Integer> minStack;
> 
>     public MinStack() {
>         result = new Stack<>();
>         minStack = new Stack<>();
>     }
> 
>     public void push(int x) {
>         result.add(x);
>         //维持辅助栈自底向上单调递减
>         //若新入栈的元素比辅助栈里的栈顶元素大，则不入辅助栈，因为新元素必定比旧元素先出栈，当前最小的元素在辅助栈中。
>         //这里要用<=，将相同的最小值均存入，否则移除一个之后就没有了。
>         if (minStack.isEmpty()||x<=minStack.peek()) {
>             minStack.push(x);
>         }
>     }
> 
>     //若当前移除的是栈中所有元素的最小值，则将其也从辅助栈中移除。
>     public void pop() {
>         if (minStack.peek().equals(result.pop())){
>             minStack.pop();
>         }
>     }
> 
>     public int top() {
>         return result.peek();
>     }
> 
>     public int min() {
>         return minStack.peek();
>     }
> }
> ```

## 树

### 二叉树的深度

> 剑指Offer-55I
>
> LeetCode-104
>
> 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

#### Solution1. 递归

> ```java
> class Solution {
>  public int TreeDepth(TreeNode root) {
>      return root==null ? 0 : Math.max(TreeDepth(root.left),TreeDepth(root.right))+1;
>  }
> }
> ```
>
> > 若求的是n叉树：
> >
> > ```java
> > class Solution {
> >     public int maxDepth(Node root) {
> >         if (root==null) return 0;
> >         int max=0;
> >         for (Node child : root.children) {
> >             int depth = maxDepth(child);
> >             if (depth>max){
> >                 max=depth;
> >             }
> >         }
> >         return max+1;
> >     }
> > }
> > ```

#### Solution2. 循环

> 1. 层次遍历二叉树，用队列存储节点。
> 2. LinkedList实现了Queue接口
> 3. remove()：删除队列中的第一个元素，当集合为空时抛出异常。
> 4. poll()：删除队列中的第一个元素，当集合为空时返回null。

> ```java
> class Solution {
>  public int TreeDepth(TreeNode root) {
>      int depth=0;
>      if (root==null){
>          return 0;
>      }
>      LinkedList<TreeNode> nodes = new LinkedList<>();
>      nodes.add(root);
>      while(!nodes.isEmpty()){
>          depth++;
>          for (int i=0;i<nodes.size();i++){
>              TreeNode front = nodes.poll();
>              if (front.left!=null){
>                  nodes.add(front.left);
>              }
>              if (front.right!=null){
>                  nodes.add(front.right);
>              }
>          }
>      }
>      return depth;
>  }
> }
> ```
>
> > 若求的是n叉树：
> >
> > ```java
> > while(!nodes.isEmpty()){
> >     depth++;
> >     //这个size一定要先提出来，在for循环里会变动
> >     int size = nodes.size();
> >     for (int i=0;i<size;i++){
> >         Node front = nodes.poll();
> >         if(front.children!=null){
> >             for (Node child : front.children) {
> >                 nodes.add(child);
> >             }
> >         }
> >     }
> > }
> > ```

### 二叉树镜像

> 剑指Offer-27
>
> LeetCode-226
>
> 操作给定的二叉树，将其变换为源二叉树的镜像。

#### Solution1. 递归

> ```java
> class Solution {
>     public void Mirror(TreeNode root) {
>         if (root==null || (root.left==null&&root.right==null)){
>             return;
>         }
>         TreeNode temp = root.left;
>         root.left=root.right;
>         root.right=temp;
>         if (root.left!=null){
>             Mirror(root.left);
>         }
>         if (root.right!=null){
>             Mirror(root.right);
>         }
>     }
> }
> ```

#### Solution2. 循环

> 1. 层次遍历，用栈存储节点，逐个交换非叶子节点的左右子树。

> ```java
> class Solution {
>     public void Mirror(TreeNode root) {
>         if (root==null || (root.left==null&&root.right==null)){
>             return;
>         }
>         Stack<TreeNode> nodes = new Stack<>();
>         nodes.push(root);
>         while (!nodes.isEmpty()){
>             TreeNode pop = nodes.pop();
>             if (pop.left!=null || pop.right!=null){
>                 TreeNode temp = pop.left;
>                 pop.left=pop.right;
>                 pop.right=temp;
>             }
>             if (pop.left!=null){
>                 nodes.push(pop.left);
>             }
>             if (pop.right!=null){
>                 nodes.push(pop.right);
>             }
>         }
>     }
> }
> ```

### 对称的二叉树

> 剑指Offer-28
>
> LeetCode-101
>
> 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

#### Solution1. 递归

> 1. 对称的二叉树，若当前节点有孩子节点，一定同时存在左右孩子，左子树和右子树对称。
>
> 2. 若两棵子树对称：
>
>     > 1. 根节点的值需相等。
>     > 2. 子树一的左孩子的值等于子树二的右孩子的值。
>     > 3. 子树一的右孩子的值等于子树二的左孩子的值。

> ```java
> class Solution {
>     boolean isSymmetrical(TreeNode pRoot){
>         return pRoot==null? true : isMirror(pRoot.left,pRoot.right);
>     }
> 
>     private boolean isMirror(TreeNode left,TreeNode right){
>         if (left==null && right==null) {
>             return true;
>         }
>         if (left==null || right==null || left.val!=right.val) {
>             return false;
>         }
>         return isMirror(left.left,right.right)&&isMirror(left.right,right.left);
>     }
> }
> 
> ```

#### Solution2. DFS

> 1. 借助一个栈，依次存入子树一的左孩子->子树二的右孩子->子树一的右孩子->子树二的左孩子。
> 2. 成对取出，继续判断两子树是否对称。

> ```java
> class Solution {
>     public boolean isSymmetric(TreeNode pRoot) {
>         if (pRoot == null){
>             return true;
>         }
>         Stack<TreeNode> stack = new Stack<>();
>         stack.push(pRoot.left);
>         stack.push(pRoot.right);
>         while (!stack.empty()) {
>             //成对取出
>             TreeNode right = stack.pop();
>             TreeNode left = stack.pop();
>             if (left == null && right == null) continue;
>             if (left == null || right == null || left.val != right.val) return false;
>             stack.push(left.left);
>             stack.push(right.right);
>             stack.push(left.right);
>             stack.push(right.left);
>         }
>         return true;
>     }
> }
> ```

#### Solution3. BFS

> 1. 借助一个队列实现

> ```java
> class Solution {
>     public boolean isSymmetric(TreeNode pRoot) {
>         if (pRoot == null){
>             return true;
>         }
>         Queue<TreeNode> queue = new LinkedList<>();
>         queue.offer(pRoot.left);
>         queue.offer(pRoot.right);
>         while(!queue.isEmpty()) {
>             TreeNode left= queue.poll();
>             TreeNode right= queue.poll();
>             if(left == null && right == null) continue;
>             if(left == null || right == null || left.val != right.val) return false;
>             queue.offer(left.left);
>             queue.offer(right.right);
>             queue.offer(left.right);
>             queue.offer(right.left);
>         }
>         return true;
>     }
> }
> ```

### 前序遍历n叉树

> LeetCode-589
>
> 给定一个 N 叉树，返回其节点值的*前序遍历*。

#### Solution1. 迭代

> ```java
> class Solution {
>     public List<Integer> preorder(Node root) {
>         Stack<Node> stack = new Stack<>();
>         List<Integer> result = new ArrayList<>();
>         if(root==null) {
>             return result;
>         }
>         stack.push(root);
>         while(!stack.isEmpty()){
>             Node current = stack.pop();
>             result.add(current.val);
>             for (int i=current.children.size()-1;i>=0;i--){
>                 stack.push(current.children.get(i));
>             }
>         }
>         return result;
>     }
> }
> ```

### 后序遍历n叉树

> LeetCode-590
>
> 给定一个 N 叉树，返回其节点值的后序遍历。

#### Solution1. 迭代

> ```java
> class Solution {
>     public List<Integer> postorder(Node root) {
>         Stack<Node> stack = new Stack<>();
>         LinkedList<Integer> result = new LinkedList<>();
>         if(root==null) {
>             return result;
>         }
>         stack.push(root);
>         while(!stack.isEmpty()){
>             Node current = stack.pop();
>             result.addFirst(current.val);
>             for (Node child : current.children) {
>                 stack.push(child);
>             }
>         }
>         return result;
>     }
> }
> ```

### 二叉搜索树的后序遍历序列

> 剑指Offer-33
>
> 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

#### Solution1. 递归

> 1. BST的后序序列的合法序列是：对于一个序列S，最后一个元素x为根节点。
> 2. 设去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。

> ```java
> class Solution {
>     public boolean verifyPostorder(int[] postorder) {
>         return verify(postorder,0,postorder.length-1);
>     }
> 
>     private boolean verify(int[] postorder,int front,int end){
>         if (front>=end){
>             return true;
>         }
>         int index=end-1;
>         //从后往前找到第一个比根节点小的节点，以此分割成两段。
>         while (index>=front && postorder[index]>postorder[end]){
>             index--;
>         }
>         if (index>=0) {
>             //检查左子树段是否均小于根节点
>             for (int i = front; i <= index; i++) {
>                 if (postorder[i] > postorder[end]) {
>                     return false;
>                 }
>             }
>         }
>         //检查左右子树两段是否均为合法序列
>         return verify(postorder,front,index) && verify(postorder,index+1,end-1);
>     }
> }
> ```

#### Solution2. 栈

> 1. 二叉搜索树后序遍历的顺序为left->right->root，后序遍历的逆序为root->right->left，即反向遍历数组。
> 2. 按root->right->left的顺序遍历时，往右子树遍历的过程中，value是越来越大的，继续进入右子树。一旦出现了value小于栈顶元素value的时候，就表示要开始进入左子树了，如果没进入则不满足二叉搜索树的定义。
> 3. 利用单调递增栈记录这些节点，只要栈顶元素还比当前节点大，就表示还是右子树，要移除，直到栈顶元素小于当前节点，或者栈为空。栈顶的上一个元素就是子树的根节点。
> 4. 数组继续往前遍历，之后的左子树的每个节点，都要比子树的根要小，才能满足二叉搜索树，否则就不是二叉搜索树。
> 5. 时间复杂度：O(N)，每个节点都只会进栈一次和出栈一次。
> 6. 空间复杂度：O(N)，一个辅助栈。

> ```java
> class Solution {
>     public boolean verifyPostorder(int[] postorder) {
>         //自栈底至栈顶，单调递增
>         Stack<Integer> stack = new Stack<>();
>         //当前元素的根节点，对于整棵BST的根节点而言，Integer.MAX_VALUE可以假设为其根节点。
>         int curRoot=Integer.MAX_VALUE;
>         //从后往前读取BST后序遍历的结果，相当于按root->right->left的顺序遍历
>         for(int i=postorder.length-1;i>=0;i--){
>             //数组继续往前遍历，剩下的均为当前根节点的左子树，其值需比当前根节点小，否则不满足BST的定义
>             if (postorder[i]>curRoot){
>                 return false;
>             }
>             //越深入右子树，值越大，入栈
>             //当出现了小于栈底值的节点，说明开始进入左子树
>             //移除栈中所有比该节点大的节点，最后一个移除的即为当前元素的根节点。
>             while (!stack.isEmpty() && postorder[i]<stack.peek()){
>                 curRoot=stack.pop();
>             }
>             stack.push(postorder[i]);
>         }
>         return true;
>     }
> }
> ```

### 从上到下打印二叉树

> 剑指Offer-32
>
> LeetCode-102
>
> 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。

#### Solution1. 层次遍历

> ```java
> class Solution {
>  ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
>      ArrayList<ArrayList<Integer>> result = new ArrayList<>();
>      if (pRoot!=null){
>          Queue<TreeNode> nodes = new LinkedList<>();
>          nodes.add(pRoot);
>          while(!nodes.isEmpty()){
>              ArrayList<Integer> line = new ArrayList<>();
>              int size = nodes.size();
>              for(int i=0;i<size;i++){
>                  TreeNode pop = nodes.poll();
>                  line.add(pop.val);
>                  if (pop.left!=null){
>                      nodes.add(pop.left);
>                  }
>                  if (pop.right!=null){
>                      nodes.add(pop.right);
>                  }
>              }
>              result.add(line);
>          }
>      }
>      return result;
>  }
> }
> ```
>
> > 遍历n叉树则改成：
> >
> > ```java
> > if (pop.children!=null){
> > 	for (Node child : pop.children) {
> > 		nodes.add(child);
> > 	}
> > }
> > ```

#### Solution2. 递归

> ```java
> class Solution {
>  ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
>      ArrayList<ArrayList<Integer>> result = new ArrayList<>();
>      print(pRoot, 1, result);
>      return result;
>  }
>  void print(TreeNode root,int layer,ArrayList<ArrayList<Integer>> result){
>      if (root==null) {
>          return;
>      }
>      if (layer>result.size()) {  //新的一层需在结果集中创建新列表
>          result.add(new ArrayList<>());
>      }
>      result.get(layer-1).add(root.val);  //获取当前层数的结果列表，添加元素
>      print(root.left,layer+1,result);
>      print(root.right,layer+1,result);
>  }
> }
> ```
>
> >遍历n叉树则改成：
> >
> >```java
> >for (Node child : root.children) {
> >    print(child,layer+1,result);
> >}
> >```

### 按之字形顺序打印二叉树

> 剑指Offer-32III
>
> 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

#### Solution1. 迭代

> ```java
> class Solution {
>     public List<List<Integer>> levelOrder(TreeNode root) {
>         List<List<Integer>> result = new ArrayList<>();
>         if (root!=null){
>             Queue<TreeNode> queue = new LinkedList<>();
>             queue.add(root);
>             while(!queue.isEmpty()){
>                 LinkedList<Integer> line = new LinkedList<>();
>                 int size = queue.size();
>                 for(int i=0;i<size;i++){
>                     TreeNode pop = queue.poll();
>                     //第奇数层，即结果集中已存入偶数层，从左往右打印，即在子队列中从后入队
>                     if ((result.size()&1)==0){
>                         line.addLast(pop.val);
>                     }
>                     //第偶数层，即结果集中已存入奇数层，从右往左打印，即在子队列中从前入队
>                     else{
>                         line.addFirst(pop.val);
>                     }
>                     if (pop.left!=null){
>                         queue.add(pop.left);
>                     }
>                     if (pop.right!=null){
>                         queue.add(pop.right);
>                     }
>                 }
>                 result.add(line);
>             }
>         }
>         return result;
>     }
> }
> ```

### 平衡二叉树

> 剑指Offer-55II
>
> LeetCode-110
>
> 输入一棵二叉树，判断该二叉树是否是平衡二叉树。

#### Solution1. 自顶向下

> 1. 自顶向下，对于每个节点，都计算一下左子树以及右子树的差的绝对值，即每个节点都判断一下。

> ```java
> 
> ```

#### Solution2. 自底向上

>1. 自底向上，后续遍历二叉树，遍历过程中求子树高度，判断是否平衡，每个节点只需要遍历一次。
>2. 改编自求树高代码，平衡的子树高度正常求，不平衡的直接设为-1。

> ```java
> class Solution {
>     public boolean IsBalanced_Solution(TreeNode root) {
>         if (isBalanced(root) == -1) {
>             return false;
>         }
>         return true;
>     }
>  
>     public int isBalanced(TreeNode root) {
>         if (root==null){
>             return 0;
>         }
>         int left = isBalanced(root.left);
>         if (left==-1){
>             return -1;
>         }
>         int right = isBalanced(root.right);
>         if (right==-1){
>             return -1;
>         }
>         int dif = left-right;
>         if (dif>1||dif<-1){
>             return -1;
>         }
>         return Math.max(left,right)+1;
>     }
> }
> ```

### 二叉树的下一个节点

> 剑指Offer-08
>
> 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

#### 思路

> 1. 若该节点有右子树，则下一个节点为其右子树最左边的节点。
> 2. 若该节点无右子树，若该节点为其父节点的左孩子，则下一个节点为其父节点。
> 3. 若该节点无右子树，若该节点为其父节点的右孩子，则一直寻找其父节点的父节点，直到节点为父节点的左孩子，则下一个节点为该节点的父节点。
> 4. 若该节点无右子树，若该节点为其父节点的右孩子，且找不到上述父节点，则该节点为最后一个结点，没有下一个节点。

#### Solution1. 

> ```java
> class Solution{
>     public TreeLinkNode GetNext(TreeLinkNode pNode){
>         if(pNode.right!=null){
>             pNode=pNode.right;
>             while(pNode.left!=null){
>                 pNode=pNode.left;
>             }
>             return pNode;
>         }
>         while(pNode.next!=null){
>             if(pNode==pNode.next.left){
>                 return pNode.next;
>             }
>             pNode=pNode.next;
>         }
>         return null;
>     }
> }
> ```

### 树的子结构

> 剑指Offer-26
>
> 输入两棵二叉树A和B，判断B是不是A的子结构，即B与A的一个子树拥有相同的结构和节点值。约定空树不是任意一个树的子结构。

#### 思路

> 1. isSubStructure函数，先序遍历树A中的每个节点，判断树A中以当前节点为根节点的子树是否包含树B。
>
>     > 1. 题目强调树B为空就不是任意树的子结构，返回false。
>     > 2. 如果当前比较的树A的子树的根节点为空，返回 false。
>     > 3. 都非空，则调用isPartSame函数判断树A中以当前节点为根节点的子树是否包含树B。
>     > 4. 若不包含，则以当前节点的子节点作为根节点，继续调用isSubStructure函数判断，有一边满足则成功。
>
> 2. isPartSame函数，判断树A中以当前节点为根节点的子树是否包含树B。
>
>     > 1. 树B为空，说明已经匹配完成，返回true。
>     > 2. 若B树非空，但树A为空，说明匹配失败，返回false。
>     > 3. 判断两个当前节点的值是否相等，相等则继续递归isPartSame函数判断两树的子节点，两边都满足则成功。

#### Solution1. 先序遍历+双递归

> ```java
> class Solution {
>     //先序遍历树A中的每个节点，判断树A中以当前节点为根节点的子树是否包含树B。
>     public boolean isSubStructure(TreeNode A, TreeNode B) {
>         //题目强调树B为空就不是任意树的子结构，返回false。
>         //如果当前比较的树A的子树的根节点为空，返回 false。
>         if (A==null || B==null) return false;
>         //都非空，则调用isPartSame函数判断树A中以当前节点为根节点的子树是否包含树B。
>         //若不包含，则以当前节点的子节点作为根节点，继续调用isSubStructure函数判断，有一边满足则成功。
>         return isPartSame(A,B) ? true : (isSubStructure(A.left,B) || isSubStructure(A.right,B));
>     }
> 
>     //判断树A中以当前节点为根节点的子树是否包含树B。
>     private boolean isPartSame(TreeNode A, TreeNode B){
>         //树B为空，说明已经匹配完成，返回true。
>         if (A==null) return false;
>         //若B树非空，但树A为空，说明匹配失败，返回false。
>         if (B==null) return true;
>         //判断两个当前节点的值是否相等，相等则继续递归isPartSame函数判断两树的子节点，两边都满足则成功。
>         return A.val!=B.val ? false : (isPartSame(A.left,B.left) && isPartSame(A.right,B.right));
>     }
> }
> ```

### 二叉搜索树与双向链表

> 剑指Offer-36
>
> 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向（循环）链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

#### Solution1. 中序遍历递归

> ```java
> class Solution {
>     Node pre = null;
>     Node head = null;
>     public Node treeToDoublyList(Node root) {
>         if(root == null){
>             return null;
>         }
>         inOrder(root);
>         //首尾相连
>         pre.right = head;
>         head.left = pre;
>         return head;
>     }
>     public void inOrder(Node root){
>         //中序遍历递归终止条件
>         if(root == null){
>             return;
>         }
>         inOrder(root.left);
>         //pre为上一个迭代的节点，即双向链表中当前节点的左节点。pre为空则表示当前节点左侧没有节点，它是最小值，即链表头节点。
>         if(pre == null){
>             head = root;
>         }else{
>             pre.right = root;
>         }
>         root.left = pre;
>         pre = root;
>         inOrder(root.right);
>     }
> }
> ```

#### Solution2. 中序遍历循环

> ```java
> class Solution {
>     public TreeNode Convert(TreeNode root) {
>         if(root==null){
>             return null;
>         }
>         Stack<TreeNode> stack = new Stack<TreeNode>();
>         TreeNode current=root;
>         TreeNode pre=null;
>         TreeNode head=null; //指向当前有序链表的头结点
>         while(current!=null||!stack.isEmpty()){
>             while(current!=null){
>                 stack.push(current);
>                 current=current.left;
>             }
>             current=stack.pop();
>             if(pre==null){
>                 head=current;
>                 pre=current;
>             }
>             else{
>                 pre.right=current;
>                 current.left=pre;
>                 pre=current;
>             }
>             current=current.right;
>         }
>         return head;
>     }
> }
> ```



### 二叉搜索树的第k大节点

> 剑指Offer-54
>
> 给定一棵二叉搜索树，请找出其中第k大的节点。

#### Solution1. DFS

> 1. BST中序遍历有升序序列，那么其逆序则是降序序列，即按照right->root->left的顺序遍历，第k个即为第k大节点。

> ```java
> class Solution {
>     int result;
>     int count;
> 
>     public int kthLargest(TreeNode root, int k) {
>         this.count=k;
>         dfs(root);
>         return result;
>     }
> 
>     private void dfs(TreeNode root) {
>         if(root == null) return;
>         dfs(root.right);
>         //已找到，终止
>         if(count==0) return;
>         //找到目标节点
>         if(count==1) {
>             result=root.val;
>         }
>         count--;
>         dfs(root.left);
>     }
> }
> ```

### 重建二叉树

> 剑指Offer-07
>
> LeetCode-105
>
> 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
>
> > 例如：输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

#### Solution1. 递归

> ```java
> class Solution {
>     public TreeNode reConstructBinaryTree(int[] pre,int[] in){
>         TreeNode root = build(pre,0,pre.length-1,in,0,in.length-1);
>         return root;
>     }
> 
>     private TreeNode build(int[] preOrder,int preLow,int preHigh,int[] inOrder,int inLow,int inHigh){
>         if(preOrder.length==0 || inOrder.length==0 || preOrder.length!=inOrder.length || preLow>preHigh || inLow>inHigh){
>             return null;
>         }
>         int val=preOrder[preLow];
>         TreeNode root=new TreeNode(val);
> 
>         int index=0;
>         while(inOrder[index]!=val){
>             index++;
>         }
>         root.left=build(preOrder,preLow+1,preLow+index-inLow,inOrder,inLow,index-1);
>         root.right=build(preOrder,index+1-inLow+preLow,preHigh,inOrder,index+1,inHigh);
>         return root;
>     }
> }
> ```

## 递归/循环

### 求1+2+...+n

> 剑指Offer-64
>
> 求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

#### Solution1. 短路与&&退出递归

> ```java
> class Solution {
>  public int Sum_Solution(int n) {
>      int sum=n;
>      boolean b = n > 0 && ((sum+=Sum_Solution(n-1))>0);
>      return sum;
>  }
> }
> ```

#### Solution2. 捕获异常退出递归

> ```java
> class Solution {
>  public  int Sum_Solution(int n) {
>      try {
>          int end=1%n;
>          return n+Sum_Solution(n-1);
>      }catch (Exception e){
>          return 0;
>      }
>  }
> }
> ```

### 汉诺塔

> LeetCode-面试题08.06
>
> 在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。需要原地修改栈。移动圆盘时受到以下限制：
>
> 1. 每次只能移动一个盘子;
> 2. 盘子只能从柱子顶端滑出移到下一根柱子;
> 3. 盘子只能叠在比它大的盘子上。

#### 思路

> 1. 首先将n个盘子最上面的n-1个盘子从A移到B柱子
> 2. 然后将最下面的一个盘子从A移到C柱子
> 3. 最后将n-1个盘子从B移到C柱子
> 4. 递归上述操作

#### Solution1. 递归

> ```java
> class Solution {
>  public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
>      //目标是从A移到C，B作暂存。
>      move(A.size(),A,B,C);
>  }
>  private void move(int n,List<Integer> A, List<Integer> B, List<Integer> C){
>      if(n==1){
>          C.add(A.remove(A.size()-1));
>          return;
>      }
>      //目标是将最下面一块的上面全部，从A移到B，C作暂存。
>      move(n-1,A,C,B);
>      //最下面一块移到C
>      C.add(A.remove(A.size()-1));
>      //剩下的在暂存区的n-1块，从B移到C，A作暂存。
>      move(n-1,B,A,C);
>  }
> }
> ```

### 裴波那契数列

> 剑指Offer-10I
>
> LeetCode-509
>
> 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：
>
> > 1. F(0) = 0,   F(1) = 1
> > 2. F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
> > 3. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

#### Solution1. 递归

> ```java
> class Solution {
>  public int Fibonacci(int n) {
>      if (n==0){
>          return 0;
>      }
>      if (n==1){
>          return 1;
>      }
>      return Fibonacci(n-1)+Fibonacci(n-2);
>  }
> }
> ```

#### Solution2. 循环

> ```java
> class Solution {
>  public int Fibonacci(int n) {
>      if (n==0){
>          return 0;
>      }
>      if (n==1){
>          return 1;
>      }
>      int pre1=1;
>      int pre2=0;
>      int result=0;
>      for (int i=2;i<=n;i++){
>          result=pre1+pre2;
>          pre2=pre1;
>          pre1=result;
>      }
>      return result;
>  }
> }
> ```

#### Solution3. 循环

> ```java
> class Solution {
>  public int Fibonacci(int n) {
>      int pre1=1;
>      int pre2=0;
>      for (int i = 0; i < n; i++) {
>          pre1+=pre2;
>          pre2=pre1-pre2;
>      }
>      return pre2;
>  }
> }
> ```

### 青蛙跳台阶

> 剑指Offer-10II
>
> LeetCode-70
>
> 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

#### Solution1. 循环

> ```java
> class Solution {
>  public int numWays(int n) {
>      if(n==0||n==1){
>          return 1;
>      }
>      if(n==2){
>          return 2;
>      }
>      int pre1=2;
>      int pre2=1;
>      int result=0;
>      for (int i=3;i<=n;i++){
>          result=pre1+pre2
>          pre2=pre1;
>          pre1=result;
>      }
>      return result;
>  }
> }
> ```

#### Solution2. 递归

> ```java
> class Solution {
>  public int JumpFloor(int target) {
>      if(target==1){
>          return 1;
>      }
>      if(target==2){
>          return 2;
>      }
>      return JumpFloor(target-1)+JumpFloor(target-2);
>  }
> }
> ```

## 回溯法

### 机器人的运动范围

> 剑指Offer-13
>
> 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。
>
> > 例如：当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

#### 思路

> 1. 目标是遍历整个矩阵。
> 2. DFS和BFS的不同点在于搜索顺序不同。
> 3. DFS先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。通过递归实现。
> 4. BFS按照平推的方式向前搜索。通常利用队列实现广度优先遍历。

#### Solution1. DFS

> 1. 可以理解为暴力法模拟机器人在矩阵中的所有路径。
>
> 2. 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为可行性剪枝。
>
> 3. 递归参数： 当前元素在矩阵中的行列索引i和j。
>     终止条件： 
>
>     > 1. 行或列索引越界
>     > 2. 数位和超出目标值k
>     > 3. 当前元素已访问过，返回0，代表不计入可达解。
>
> 4. 递推工作：
>
>     > 1. 标记当前单元格 ：将单元格索引(i, j)存入Set中，代表此单元格已被访问过。但Java的Set存int[]是地址，总是不会重复，所以我们改用二维表boolean[]标记。
>     > 2. 搜索下一单元格： 开启下层递归 。
>
> 5. 回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。

> ```java
> class Solution {
>     //要回溯，应保证全局性。
>     int m, n, k;
>     boolean[][] visited;
> 
>     public int movingCount(int m, int n, int k) {
>         this.m=m; this.n=n; this.k=k;
>         this.visited = new boolean[m][n];
>         return dfs(0, 0);
>     }
> 
>     private int dfs(int i,int j) {
>         if(i>=m || j>=n || calculate(i)+calculate(j)>k || visited[i][j]) return 0;
>         visited[i][j]=true;
>         return 1 + dfs(i+1, j) + dfs(i, j+1);
>     }
>     
>     private int calculate(int n) {
>         int sum=0;
>         while(n>0){
>             sum+=n%10;
>             n/=10;
>         }
>         return sum;
>     }
> }
> ```

#### Solution1. BFS

> 1. 初始化：将机器人初始点(0, 0)加入队列queue。
>
> 2. 迭代终止条件：queue 为空，代表已遍历完所有可达解。
>
> 3. 迭代工作：
>
>     > 1. 单元格出队： 将队首单元格的索引弹出，作为当前搜索单元格。
>     >
>     > 2. 判断是否跳过： 以下情况执行continue。
>     >
>     >     > 1. 行或列索引越界
>     >     > 2. 数位和超出目标值k
>     >     > 3. 当前元素已访问过
>     >
>     > 3. 标记当前单元格 ：将单元格索引(i, j)存入Set中，代表此单元格已被访问过。但Java的Set存int[]是地址，总是不会重复，所以我们改用二维表boolean[]标记。
>     >
>     > 4. 单元格入队： 将当前元素的下方、右方单元格的索引加入queue。
>
> 4. 返回值：全局变量count。

> ```java
> class Solution {
>     public static int movingCount(int m, int n, int k) {
>         int count = 0;
>         boolean[][] visited = new boolean[m][n];
>         Queue<int[]> queue= new LinkedList<>();
>         queue.add(new int[]{0,0});
>         while(queue.size()>0){
>             int[] coordinate=queue.poll();
>             int i=coordinate[0];
>             int j=coordinate[1];
>             if(i>=m || j>=n || calculate(i)+calculate(j)>k || visited[i][j]) continue;
>             visited[i][j]=true;
>             count++;
>             queue.add(new int[]{i+1,j});
>             queue.add(new int[]{i,j+1});
>         }
>         return count;
>     }
>     private static int calculate(int n) {
>         int sum=0;
>         while(n>0){
>             sum+=n%10;
>             n/=10;
>         }
>         return sum;
>     }
> }
> ```

### 矩阵中的路径

> 剑指Offer-12
>
> LeetCode-79
>
> 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。

#### 思路

> 1. DFS：利用深度优先搜索，通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推，从而暴力遍历矩阵中所有字符串可能性。
>
> 2. 剪枝： 在搜索中，遇到这条路不可能和目标字符串匹配成功的情况，则应立即返回，称为可行性剪枝。
>
>     > 1. 此矩阵元素和目标字符不同
>     > 2. 此元素已被访问

#### Solution1. DFS+剪枝

> 1. 递归参数： 当前元素在矩阵board中的行列索引i和j，当前目标字符在word 中的索引k 。
>
> 2. 终止条件：
>
>     > 1. 以下情况返回false
>     >
>     >     > 1. 行或列索引越界
>     >     > 2. 当前矩阵元素与目标字符不同
>     >     > 3. 当前矩阵元素已访问过
>     >
>     > 2. 以下情况返回true
>     >
>     >     > 1. 字符串word已全部匹配，即k=len(word)-1 
>
> 3. 递推工作：
>
>     > 1. 标记当前矩阵元素：将 board[i,j]值暂存于变量tmp，并修改为字符 '/' ，代表此元素已访问过，防止之后搜索时重复访问。
>     > 2. 搜索下一单元格： 朝当前元素的 上、下、左、右四个方向开启下层递归，使用或连接，代表只需一条可行路径 ，并记录结果。
>     > 3. 还原当前矩阵元素：将tmp暂存值还原至board[i,j]元素。递归搜索匹配字符串过程中，需要 `board[i][j] = '/'` 来防止 ”走回头路“ 。当匹配字符串不成功时，会回溯返回，此时需要`board[i][j] = tmp` 来”取消对此单元格的标记”。 在DFS过程中，每个单元格会多次被访问的， `board[i][j] = '/'`只是要保证在当前匹配方案中不要走回头路。
>
> 4. 回溯返回值：返回是否搜索到目标字符串。

> ```java
> class Solution {
>     //要回溯，应保证全局性。
>     boolean[][] visited;
>     char[][] board;
>     char[] str;
> 
>     public boolean exist(char[][] board, String word) {
>         this.visited = new boolean[board.length][board[0].length];
>         this.board = board;
>         this.str = word.toCharArray();
>         for (int i = 0; i < board.length; i++) {
>             for (int j = 0; j < board[0].length; j++) {
>                 if (dfs(i, j, 0)){
>                     return true;
> 				}
>             }
>         }
>         return false;
>     }
> 
>     private boolean dfs(int i, int j, int k) {
>         //判断边界、剪枝
>         if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] != str[k] || visited[i][j] == true){
>             return false;
>         }
>         //拼接完成
>         if (k == str.length - 1) return true;
>         //目标元素与对应字符匹配，且该元素未被访问过，标记该元素为已访问。
>         visited[i][j] = true;
>         //依次向四个方向探索，符合即继续深入探索，不合符则换方向
>         boolean result = dfs(i + 1, j, k + 1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);
>         //探索完毕，需要原路回溯结果，防止在上述判断中被拦截，需释放visited中的已访问标记。
>         visited[i][j] = false;
>         return result;
>     }
> }
> ```

### 二叉树中和为某一值的路径

> 剑指Offer-34
>
> LeetCode-113

#### Solution1. 先序遍历+路径记录

> ```java
> class Solution {
>     //存放从根到叶和为目标值的路径
>     List<List<Integer>> result = new ArrayList<>();
>     //存放当前路径
>     LinkedList<Integer> path = new LinkedList<>();
> 
>     public List<List<Integer>> pathSum(TreeNode root, int sum) {
>         recur(root, sum);
>         return result;
>     }
> 
>     private void recur(TreeNode root, int sum) {
>         if(root == null) return;
>         path.add(root.val);
>         sum-=root.val;
>         if(sum == 0 && root.left == null && root.right == null)
>             result.add(new LinkedList(path));
>         recur(root.left, sum);
>         recur(root.right, sum);
>         path.removeLast();
>     }
> }
> ```
>
> ```java
> import java.util.ArrayList;
> import java.util.List;
> 
> class Solution {
>     public List<List<Integer>> pathSum(TreeNode root, int sum) {
>         List<List<Integer>> result = new ArrayList<>();
>         if(root == null) return result;
>         findPath(root,sum,0,result,new ArrayList<Integer>());
>         return result;
>     }
> 
>     //path存放当前路径，curSum记录当前路径节点值的和，result存放从根到叶和为目标值的路径
>     private static void findPath(TreeNode root, int sum, int curSum,List<List<Integer>> result,List<Integer> path) {
>         path.add(root.val);
>         curSum+=root.val;
>         if(curSum == sum && root.left == null &&root.right == null) {
>             //得到一个符合要求的路径时，创建一个新的ArrayList，拷贝当前路径到其中，并添加到lists中
>             result.add(new ArrayList(path));
>         }
>         if(root.left != null) {
>             findPath(root.left,sum,curSum,result,path);
>             //递归结束时，该留的路径已经记录了，不符合的路径也都不用理，删掉当前路径节点的值
>             path.remove(path.size()-1);
>         }
>         if(root.right != null) {
>             findPath(root.right,sum,curSum,result,path);
>             //递归结束时，该留的路径已经记录了，不符合的路径也都不用理，删掉当前路径节点的值
>             path.remove(path.size()-1);
>         }
>     }
> }
> ```

## 分治

### 合并两个排序的链表

> 剑指Offer-25
>
> LeetCode-21
>
> 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

#### Solution1. 虚拟头结点分治

> ```java
> class Solution {
>     public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
>         //声明一个头结点，否则要处理好多空情况。
>         ListNode head=new ListNode();
>         ListNode current=head;
>         while(l1!=null && l2!=null){
>             if(l1.val<=l2.val){
>                 current.next=l1;
>                 current=current.next;
>                 l1=l1.next;
>             }
>             else {
>                 current.next=l2;
>                 current=current.next;
>                 l2=l2.next;
>             }
>         }
>         current.next=(l1==null)?l2:l1;
>         return head.next;
>     }
> }
> ```

#### Solution2. 递归

> ```java
> class Solution {
>     public ListNode mergeTwoLists(ListNode l1, ListNode l2){
>         if(l1==null){
>             return l2;
>         }
>         if(l2==null){
>             return l1;
>         }
>         if(l1.val<l2.val){
>             l1.next=mergeTwoLists(l1.next,l2);
>             return l1;
>         } 
>         else{
>             l2.next=mergeTwoLists(l1,l2.next);
>             return l2;
>         }
>     }
> }
> ```

## 动态规划/贪心

### 连续子数组的最大和

> 剑指Offer-42
>
> LeetCode-53
>
> 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。

#### Solution1. 动态规划

> 1. f(i)：以array[i]为末尾元素的子数组的和的最大值
> 2. f(i)=max(f(i-1)+array[i] ,array[i])
> 3. res：所有子数组的和的最大值
> 4. res=max(res,f(i))

> ```java
> class Solution {
>     public int FindGreatestSumOfSubArray(int[] array) {
>         int result=array[0];
>         int max=array[0];
>         for (int i=1;i<array.length;i++){
>             max=Math.max(max+array[i],array[i]);
>             result=Math.max(max,result);
>         }
>         return result;
>     }
> }
> ```

### 剪绳子

> 剑指Offer-14
>
> LeetCode-343
>
> 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？
>
> > 例如：当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

#### 思路

> | **绳子长度** | **切分方案**      | **最大乘积** | **推论**                              |
> | ------------ | ----------------- | ------------ | ------------------------------------- |
> | 2            | 1+1               | 1            | 2不应拆分                             |
> | 3            | 1+2               | 2            | 3不应拆分                             |
> | 4            | 1+3 2+2           | 4            | 拆出1不好                             |
> | 5            | 1+4 2+3           | 6            | 拆出1不好                             |
> | 6            | 1+5 2+4 2+2+2 3+3 | 9            | 2的倍数与全拆成2等价，拆出3比2更优    |
> | 7            | 2+2+3             | 12           | 综上，不要拆出1，优先拆出3，其次拆出2 |

#### Solution1. 动态规划

> 1. 先用除法算出能拆成多少个3，如果余数是1，则少拆1个3。余下的数全拆成2。

> ```java
> class Solution {
>     public int cuttingRope(int n) {
>         if (n<4){
>             return n-1;
>         }
>         int count=n/3;
>         if (n%3==1){
>             return (int) (Math.pow(3,count-1)*Math.pow(2,(n-3*(count-1))/2));
>         }
>         return (int) (Math.pow(3,count)*Math.pow(2,(n-3*(count))/2));
>     }
> }
> ```

#### Solution2. 动态规划

> 1. 逐步尝试拆出3来，当只剩下4时，由于4拆成2+2要优于1+3，所以停止拆分，默认返回2+2，即4。

> ```java
> class Solution {
>     public int cuttingRope(int n) {
>         if(n<4){
>             return n-1;
>         }        
>         int max=1;
>         while(n>4){
>             n-=3;
>             max*=3;
>         }
>         return max*n;
>     }
> }
> ```

### 礼物的最大价值

> 剑指Offer-47
>
> 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

#### 思路

> 1. 设f(i,j)为从棋盘左上角走至单元格(i,j)的礼物最大累计价值
>
> 2. f(i,j)等于f(i,j-1)和 f(i-1,j)中的较大值加上当前单元格礼物的价值matrix(i,j)
>
> 3. 递归关系f(i,j)=max[f(i,j−1),f(i−1,j)]+matrix(i,j)作为动态转移方程
>
> 4. 设左上角为初始坐标，横坐标为i，纵坐标为j，分情况的状态转移方程：
>
>     > 1. i=0，j=0：f(i,j)=f(i,j)  //初始状态
>     > 2. i=0，j!=0：f(i,j)=f(i,j-1)+matrix(i,j)  //由于线路不能往回走，上一步只能是f(i,j-1)
>     > 3. i!=0，j=0：f(i,j)=f(i-1,j)+matrix(i,j)  //由于线路不能往回走，上一步只能是f(i-1,j)
>     > 4. i!=0，j!=0：f(i,j)=max[f(i,j−1),f(i−1,j)]+matrix(i,j)  //由于线路不能往回走，上一步可能是f(i,j−1)或f(i−1,j)
>
> 5. 自顶向下遍历，每个位置修改为可能的最大值。使得空间复杂度为O(1)。
> 6. 最后的结果存储在了最后一个位置即右下角。总是需要遍历完整个矩阵，时间复杂度为O(m*n)。

#### Solution1. 动态规划

> 1. 时间复杂度：O(m*n)，3ms。
>
> 2. 空间复杂度：O(1)，42.7MB。

> ```java
> class Solution {
>     public int maxValue(int[][] grid) {
>         int x=grid.length;
>         int y=grid[0].length;
>         //自顶向下遍历，每个位置修改为可能的最大值
>         //外层循环应是二维数组中一维数组的个数
>         for(int i=0;i<x;i++){
>             //内层循环应是单个一维数组的长度
>             for(int j=0;j<y;j++){
>                 if (i==0&&j==0){  //该位置值无变化
>                     continue;
>                 }
>                 if(i==0){
>                     grid[i][j]+=grid[i][j-1];
>                 }
>                 else if(j==0){
>                     grid[i][j]+=grid[i-1][j];
>                 }
>                 else{
>                     grid[i][j]+=Math.max(grid[i][j-1],grid[i-1][j]);
>                 }
>             }
>         }
>         //最后的结果存储在了最后一个位置即右下角
>         return grid[x-1][y-1];
>     }
> }
> ```

#### Solution2. 动态规划优化

> 1. 时间复杂度：O(m*n)，2ms。
> 2. 空间复杂度：O(1)，42.4MB。
> 3. 当矩阵很大时，i=0或j=0的情况仅占极少数，相当于循环每轮都冗余了一次判断。整个过程总是要遍历完x*y的表，因此可以先初始化矩阵第一行和第一列，再开始遍历递推。

> ```java
> class Solution {
>     public int maxValue(int[][] grid) {
>         int x=grid.length;
>         int y=grid[0].length;
>         for(int i=1;i<x;i++){
>             grid[i][0]+=grid[i-1][0];
>         }
>         for(int j=1;j<y;j++){
>             grid[0][j]+=grid[0][j-1];
>         }
>         for(int i=1;i<x;i++){
>             for(int j=1;j<y;j++){
>                 grid[i][j]+=Math.max(grid[i][j-1],grid[i-1][j]);
>             }
>         }
>         return grid[x-1][y-1];
>     }
> }
> ```

### 股票的最大利润

> 剑指Offer-63
>
> 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？
>
> > 例如：输入[7,1,5,3,6,4]，输出5。
> >
> > 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。

#### 思路

> 1. 设f(n)为第n天的最大利润，即以n-1为结尾位置的子数组的最大利润。
> 2. 前n-1天的最大利润f(n-1)，与第n天的卖出价格减去前n-1天的最低入手价格，两者之间的较大值即为第n天的最大利润f(n)。
> 3. 得到状态转移方程为：f(n)=max(f(n-1),price[n]-min(price in 0~n-1))
> 4. 首日利润为0，数组长度为n，我们把数组索引作为参数，初始状态：f(0)=0
> 5. 每次都把最大利润更新到当前数组片段末尾，最后的返回值：f(n-1)

#### Solution1. 

> 1. 时间复杂度：O(n)，3ms。需遍历整个列表。
> 2. 空间复杂度：O(1)，39.1MB。使用了两个全局变量minPrice、profit。

> ```java
> class Solution {
>     public int maxProfit(int[] prices) {
>         int minPrice=Integer.MAX_VALUE;
>         int profit=0;
>         for(int i=0;i<prices.length;i++){
>             minPrice=Math.min(minPrice,prices[i]);
>             profit=Math.max(profit,prices[i]-minPrice);
>         }
>         return profit;
>     }
> }
> ```

### 滑动窗口的最大值

> 剑指Offer-59I
>
> LeetCode-239
>
> 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。

#### 思路

> 1. 长度为n的数组，长度为k的窗口，则窗口总数为n-k+1。
> 2. 获取每个窗口中最大值的遍历时间复杂度为O(k)，所以总时间复杂度为O(n*k)，所以算法的关键在于如何使获取单个窗口最大值的时间复杂度降为O(1)。
> 3. 创建一个双端队列，维持这个队列有序递减，这样队首即是窗口内最大值。每遍历一个元素时，若该元素比队尾元素小，则直接入队，否则从队尾开始把比它小的元素移除。因为若新元素较小，窗口滑动后可能就成了较大值，所以留着备用；但若新元素较大，队列中之前入队的较新元素小的元素，将没有任何用处了，所以移除。
> 4. 队列中存储的是元素的索引，这样便于判断首节点是否已超出窗口范围。若存储元素的值，想要用变量统计是否超出，我是没做出来。

#### Solution1. 动态规划

> 1. 时间复杂度：O(n)。线性遍历数组占用O(N)，每个元素最多仅入队和出队一次，因此单调队列占用O(2N) 。
> 2. 空间复杂度：O(k)。双端队列k个元素，即窗口大小。

> ```java
> class Solution {
>     public int[] maxSlidingWindow(int[] nums, int k) {
>         if(nums==null||nums.length==0||k<1||k>nums.length){
>             return new int[]{};
>         }
>         int[] result=new int[nums.length-k+1];
>         LinkedList<Integer> window = new LinkedList<>();
>         for(int i=0;i<nums.length;i++){
>             while ((!window.isEmpty())&&nums[i]>nums[window.peekLast()]){
>                 window.removeLast();
>             }
>             window.add(i);
>             if (window.peekFirst()+k==i){
>                 window.removeFirst();
>             }
>             //判断是否已形成窗口
>             if (i>=k-1){
>                 result[i+1-k]=nums[window.peekFirst()];
>             }
>         }
>         return result;
>     }
> }
> ```

### 变态跳台阶

> 剑指Offer-10III
>
> 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

#### 思路

> 1. 当每次可以跳1或2级台阶时，最后一跳有两种可能，在n-1层或n-2层，所以跳到第n级的总跳法=跳到n-1层的可能数+跳到n-2层的可能数。即f(n)=f(n-1)+f(n-2)，同理可得当每次可以跳1到n级时，f(n)=f(n-1)+f(n-2)+…..+f(1)，跟f(n-1)=f(n-2)+…+f(1)整理一下，可得f(n)=2*f(n-1)。

#### Solution1. 

> ```java
> class Solution {
>     public static int JumpFloorII(int target) {
>         if (target<=0){
>             return -1;
>         }
>         if(target==1){
>             return 1;
>         }
>         return 2*JumpFloorII(target-1);
>     }
> }
> ```

## 数学

### 回文数判断

> LeetCode-9
>
> 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

#### 思路

> 1. 利用已知信息，可优化的时间复杂度为遍历数字的一半。
> 2. 若转成字符串，空间复杂度较高，可优化的空间复杂度为O(1)。
> 3. 反转数字后半段

#### Solution1. 

> 1. 0是回文数
> 2. 非0的以0结尾的数，肯定不是回文数。
> 3. 非0结尾的数，长度为奇数时，若反转后的新数大于原数的剩余，说明遍历已过半，新数要去掉一位。
> 4. 非0结尾的数，长度为偶数时，若反转后的新数等于原数的剩余，说明遍历刚好一半。

> ```java
> class Solution {
>  public boolean isPalindrome(int x) {
>      //非0的以0结尾的数，肯定不是回文数。
>      if (x!=0&&x%10==0){
>          return false;
>      }
>      int reverseHalf=0;
>      while(reverseHalf<x){
>          reverseHalf=reverseHalf*10+x%10;
>          x/=10;
>      }
>      //偶数或奇数情况下的回文数判断，不适应于末尾为0的数，所以提前判断。
>      return reverseHalf==x || reverseHalf/10==x;
>  }
> }
> ```

### 数值的整数次方

#### Solution1. 快速幂

> 1. 当求奇数次方2k+1时，相当于求乘k次基数的平方再乘多一次基数。

> ```java
> class Solution {
>     public double myPow(double x, int n) {
>         if (x==0) return 0;
>         double result=1.0;
>         double base=x;
>         long times=n;
>         if (n<0) times=-times;
>         /*
>         若把上面两行写成下面这样，指数为-2147483648时还会输出-2147483648。
>         long times;
>         if (n>=0) {
>             times=n;
>         }
>         else {
>             times=-n;
>             //应改成times=-(long)n;
>             //由于传入的n是int类型，因此-n超出取值范围，因此要先转为long。
>         }
>         */
>         //当求奇数次方2k+1时，相当于求乘k次基数的平方再乘多一次基数。
>         while(times>0){
>             if((times&1)==1) result*=base;
>             base*=base;
>             times>>=1;
>         }
>         return n>=0 ? result : 1/result;
>     }
> }
> ```

## 位运算

### 不用加减乘除做加法

> 剑指Offer-65
>
> 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

#### 思路

> 1. ^：异或，不一样则为1
> 2. &：与，都是1则为1
> 3. a的二进制+b的二进制=二进制c，c可拆解成(a^b)+(a&b<<1)，再继续拆解，直至拆解至一个数为0，剩下的数即为两数相加之和，即(a&b<<1)为0，此次a^b的值即为a+b之和。

#### Solution1. 

> ```java
> class Solution {
>  public int Add(int num1,int num2) {
>      int temp=0;
>      while(num1!=0){
>          temp=num1^num2;
>          num1=(num1&num2)<<1;
>          num2=temp;
>      }
>      return num2;
>  }
> }
> ```

### 二进制中1的个数

> 剑指Offer-15
>
> LeetCode-191
>
> 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

#### Solution1. 逐位右移

> 1. 逐个右移一位判断低位是否为1

> ```java
> class Solution {
>  public int NumberOf1(int n) {
>      int count=0;
>      while (n!=0){
>          if ((n&1)==1){
>              count++;
>          }
>          n=n>>>1;
>      }
>      return count;
>  }
> }
> ```

#### Solution2. 

> 1. 如果一个整数不为0，那么这个整数至少有一位是1。把这个整数减1，相当于把最右边的一个1开始的所有位都取反了。再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。一个整数的二进制有多少个1，就可以进行多少次这样的操作。

> ```java
> class Solution {
>  public int hammingWeight(int n) {
>      int count = 0;
>      while(n!= 0){
>          n = n & (n - 1);            
>          count++;
>      }
>      return count;
>  }
> }
> ```

### 只出现一次的字符

> LeetCode-136
>
> 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

#### Solution1. 异或

>1. 时间复杂度：O(n)，1ms。需遍历一遍。
>2. 空间复杂度：O(1)，40.5 MB。

> ```java
> class Solution {
>  public int singleNumber(int[] nums) {
>      int result=0;
>      for(int i=0;i<nums.length;i++){
>          result^=nums[i];
>      }
>      return result;
>  }
> }
> ```

## 字符串

### 左旋转字符串

> 剑指Offer-58II
>
> 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。
>
> > 例如：输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

#### Solution1. 三次逆序

> ```java
> class Solution {
>  public String LeftRotateString(String str,int n) {
>      if (str==null||str.length()==0||n==0){
>          return str;
>      }
>      char[] chars = str.toCharArray();
>      int index=n%str.length();
>      reverse(chars,0,chars.length-1);
>      reverse(chars,0,chars.length-index-1);
>      reverse(chars,chars.length-index,chars.length-1);
>      return new String(chars);
>  }
>  void reverse(char[] chars,int begin,int end){
>      while (begin<end){
>          char temp = chars[begin];
>          chars[begin]=chars[end];
>          chars[end]=temp;
>          begin++;
>          end--;
>      }
>  }
> }
> ```

#### Solution2. API

> ```java
> class Solution {
>  public String LeftRotateString(String str,int n) {
>      if (str==null||str.length()==0||n==0){
>          return str;
>      }
>      int index = n % str.length();
>      str+=str.substring(0,index);
>      return str.substring(index,str.length());
>  }
> }
> ```

### 第一个只出现一次的字符

> 剑指Offer-50
>
> 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

#### 思路

> 1. 遍历LinkedHashMap：自定义Iterator或foreach
>     `for(Map.Entry<Character,Boolean> entry : linkedHashMap.entrySet()){`

#### Solution1. LinkedHashMap有序存储

> ```java
> class Solution {
>  public char firstUniqChar(String s) {
>      LinkedHashMap<Character, Boolean> map = new LinkedHashMap<>();
>      char[] chars = s.toCharArray();
>      for (char c:chars){
>          if (map.containsKey(c)){
>              map.put(c,true);
>          }
>          else {
>              map.put(c,false);
>          }
>      }
>      for(Map.Entry<Character, Boolean> entry : map.entrySet()){
>          if (entry.getValue()==false){
>              return entry.getKey();
>          }
>      }
>      return ' ';
>  }
> }
> ```

### 表示数值的字符串 

> 剑指Offer-20	
>
> LeetCode-65
>
> 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。
>
> > 例如：字符串"+100"、"5e2"、"-123"、"3.1416"、"0123"及"-1E-16"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"及"12e+5.4"都不是。

#### 思路

> 1. aEb表示a × 10^b，e-10表示10^(-10)

#### Solution1.

> ```java
> class Solution {
>  public boolean isNumeric(char[] str) {
>      boolean hasDecimal=false;
>      boolean hasE=false;
>      for (int i=0;i<str.length;i++){
>          if (str[i]=='+'||str[i]=='-'){
>              if (i!=0){  //若+-不在首位，必须紧跟在e后
>                  if (str[i-1]!='e' && str[i-1]!='E'){
>                      return false;
>                  }
>              }
>          }
>          else if (str[i]=='.'){
>              if (hasDecimal){    //.不能出现两次
>                  return false;
>              }
>              if (i==0||i==str.length-1){ //.不能在开头和结尾
>                  return false;
>              }
>              if (hasE){
>                  return false;   //.不能存在于e后
>              }
>              hasDecimal=true;
>          }
>          else if (str[i]=='e'||str[i]=='E'){
>              if (hasE){  //不能同时有2个e
>              return false;
>              }
>              if (i==str.length-1){   //e不能是最后一位
>                  return false;
>              }
>              hasE=true;
> 
>          }
>          else if (str[i]<'0'||str[i]>'9'){    //若非+-.e，必须为数字
>              return false;
>          }
>      }
>      return true;
>  }
> }
> ```

#### Solution2. 编译原理自动机

> 1. 正则引擎的实现
>
> 2. 状态迁移表："+-n.ne+-n"每一个字符代表一个状态，数组的1和0代表状态之间是否能直接跳跃，循环里的cur代表当前状态的行索引，arr数组维护列索引对应状态的语义，内部遍历列索引是要找下一个能跳转的状态，并改变行索引。
>
>     ![image-20200416131450361](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200416131450361.png)
>
>     ![image-20200416131458985](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200416131458985.png)
>
>     ![image-20200416131504444](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200416131504444.png)

> ```java
> 
> ```

### 替换空格

> 剑指Offer-05
>
> 请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

#### 思路

> 1. 首先问清要求，是需在原来的字符串上做替换，还是可以新开辟一个字符串做替换。

#### Solution1. 开辟新空间

> ```java
> class Solution {
>     public String replaceSpace(StringBuffer str) {
>         StringBuilder result = new StringBuilder();
>         int i=0;
>         if (str.getChars(0,0););
>         char[] chars = s.toCharArray();
>         for (char c : chars) {
>             if (c==' ') result.append("%20");
>             else result.append(c);
>         }
>         return result.toString();
>     }
> }
> ```

#### Solution2. 原字符串做替换

> 1. 若从前往后替换，后面的字符要不断往后移动，要多次移动，效率低下。
> 2. 所以我们先统计空格的数量，计算需要多少空间。从后往前遍历，则每个字符只为移动一次，效率更高一点。

> ```java
> public class Solution {
>     public String replaceSpace(StringBuffer str) {
>         int count=0;
>         for(int i=0;i<str.length();i++){
>             if (str.charAt(i)==' ') count++;
>         }
>         int oldIndex=str.length()-1;
>         str.setLength(str.length()+count*2);
>         int newIndex=str.length()-1;
>         while(oldIndex>=0){
>             if (str.charAt(oldIndex)==' '){
>                 str.setCharAt(newIndex--,'0');
>                 str.setCharAt(newIndex--,'2');
>                 str.setCharAt(newIndex--,'%');
>                 if (--count==0) break;;
>             }
>             else str.setCharAt(newIndex--,str.charAt(oldIndex));
>             oldIndex--;
>         }
>         return str.toString();
>     }
> }
> ```

### 翻转单词顺序

> 剑指Offer-58I
>
> LeetCode-151
>
> 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

#### Solution1. 双指针

> ```java
> class Solution {
>     public String reverseWords(String s) {
>         //如果要求"   "返回的结果是"   "的话
>         //if(s.trim().equals("")) return s;
>         s=s.trim();
>         int start=s.length()-1;
>         int end=start;
>         StringBuilder result = new StringBuilder();
>         while (start>=0){
>             //找到当前左边第一个空格
>             while (start>=0 && s.charAt(start)!=' '){
>                 start--;
>             }
>             result.append(s.substring(start+1,end+1));
>             result.append(' ');
>             //找到当前左边第一个非空格
>             while (start>=0 && s.charAt(start)==' '){
>                 start--;
>             }
>             end=start;
>         }
>         return result.toString().trim();
>     }
> }
> ```

#### Solution2. 栈

> ```java
> class Solution {
>     public String reverseWords(String s) {
>         //如果要求"   "返回的结果是"   "的话
>         //if(s.trim().equals("")) return s;
>         s=s.trim();
>         StringBuilder result = new StringBuilder();
>         Stack<Character> stack = new Stack<>();
>         int index=s.length()-1;
>         while(index>=0){
>             char c=s.charAt(index--);
>             if (c==' ' && !stack.isEmpty()){
>                 while (!stack.isEmpty()){
>                     result.append(stack.pop());
>                 }
>                 result.append(' ');
>             }
>             else if (c!=' '){
>                 stack.push(c);
>             }
>         }
>         while (!stack.isEmpty()){
>             result.append(stack.pop());
>         }
>         return result.toString().trim();
>     }
> }
> ```

#### Solution3. API

> 1. 正则匹配若干个空格，split拆分成list。
> 2. 反转list顺序
> 3. 给list中每个单词间加上一个空格

> ```java
> class Solution {
>     public String reverseWords(String s) {
>         List<String> strs = Arrays.asList(s.trim().split("\\s+"));
>         Collections.reverse(strs);
>         return String.join(" ",strs);
>     }
> }
> ```

#### Solution4. API

> ```java
> class Solution {
>     public String reverseWords(String s) {
>         String[] strs = s.trim().split(" ");
>         StringBuilder result=new StringBuilder();
>         for(int i=strs.length-1;i>=0;i--){
>             //用==不对
>             if (!strs[i].trim().equals("")) result.append(strs[i]).append(" ");
>         }
>         return result.toString().trim();
>     }
> }
> ```

### 把字符串转为整数

>剑指Offer-67
>
>LeetCode-8
>
>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
>
>> 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。在任何情况下，若函数不能进行有效的转换时，请返回 0。
>
>> 说明：假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

#### Solution1. 

> ```java
> class Solution {
>     public int strToInt(String str) {
>         char[] chars=str.trim().toCharArray();
>         if(chars.length==0) return 0;
>         long result=0;
>         boolean positive=true;
>         int index=0;
>         if (chars[0]=='-'){
>             positive=false;
>             index=1;
>         }
>         if (chars[0]=='+') index=1;
>         for (int i=index;i<chars.length;i++){
>             if (chars[i]<'0' || chars[i]>'9'){
>                 break;
>             }
>             result=result*10+(chars[i]-'0');
>             if (result>(long)Integer.MAX_VALUE && positive==true) return Integer.MAX_VALUE;
>             if ((result>(long)Integer.MAX_VALUE+1) && positive==false) return Integer.MIN_VALUE;
>         }
>         return positive ? (int)result : (int)(-1*result);
>     }
> }
> ```